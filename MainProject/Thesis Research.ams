## ams_version=1.0

Model Main_Thesis_Research {
    Section Models {
        Section Common_Elements {
            Section Common_Variables {
                DeclarationSection ReserveDeclaration {
                    Variable VC_Reserve {
                        IndexDomain: (iTime,iGenerator,iReserveProduct);
                        Range: nonnegative;
                    }
                }
                DeclarationSection LossDeclaration {
                    Variable VC_PowerLossByTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Property: Inline;
                        Definition: PD_TransmissionLoss(iBus, iBus2)*VC_PowerTransmitted(iTime, iBus, iBus2)/(1 - PD_TransmissionLoss(iBus, iBus2));
                    }
                }
                DeclarationSection TransmissionDeclaration {
                    Variable VC_PowerTransmitted {
                        IndexDomain: (iTime,iBus,iBus2);
                        Range: nonnegative;
                    }
                    Variable VC_VoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Range: free;
                    }
                }
                DeclarationSection GenerationSlackDeclaration {
                    Variable VC_CurtailmentByBus {
                        IndexDomain: (iTime,iBus);
                        Range: free;
                    }
                    Variable VC_UnderGenerationSlack {
                        IndexDomain: (iTime,iBus);
                        Range: nonnegative;
                    }
                    Variable VC_OverGenerationSlack {
                        IndexDomain: (iTime,iBus);
                        Range: nonnegative;
                    }
                }
                DeclarationSection PowerGenerationDeclaration {
                    Variable VC_PowerGenerated {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Range: nonnegative;
                    }
                }
            }
        }
        Section Unit_Commitment_Model {
            Section UC_ObjectiveFunction {
                MathematicalProgram M_UC_MinimizeTotalCost {
                    Objective: VC_ED_TotalCost;
                    Direction: minimize;
                    Constraints: S_UC_Constraints;
                    Variables: S_UC_Variables;
                    Type: Automatic;
                }
            }
            Section UC_Configurations {
                DeclarationSection UC_ConstraintSetDeclarations {
                    Set S_UC_Variables {
                        SubsetOf: AllVariables;
                        Definition: {
                            Common_Variables*AllVariables
                            +
                            UC_Variables*AllVariables
                            
                            
                            -
                            
                            if (not PI_EnableTranmissionConstraints) then
                            
                            {
                              'VC_PowerTransmitted',
                              'VC_VoltageAngle'
                            }
                            endif
                            
                            -
                            if (not PI_EnableReserveConstraints) then
                            
                            {
                            	'VC_Reserve'
                            }
                            
                            endif
                            
                            -
                            if (not PI_AddSlackVariables) then
                            
                            {
                            	'VC_UnderGenerationSlack',
                            	'VC_OverGenerationSlack'
                            }
                            
                            endif
                        }
                    }
                    Set S_UC_Constraints {
                        SubsetOf: AllConstraints;
                        Definition: {
                            UC_Constraints*AllConstraints
                            
                            -
                            
                            if (not PI_EnableTranmissionConstraints) then
                            
                            
                              UC_Constraints*AllConstraints
                            
                            
                            
                            endif
                            
                            -
                            if (not PI_EnableRampingConstraints) then
                            
                            
                              UC_Constraints*AllConstraints
                            
                            
                            endif
                            
                            -
                            if (not PI_EnableReserveConstraints) then
                            
                            
                              UC_Constraints*AllConstraints
                            
                            endif
                            
                            
                            - if (PI_EnableTranmissionConstraints) then
                             'CE_UC_GenerationSatisfiesTotalLoadOverTime'
                            
                            endif
                            
                            - 'CG_UC_MaximumTransmission'
                            - 'CG_UC_MinimumTransmission'
                            - 'CE_UC_LogicalConstraint'
                            - 'CE_UC_VoltageAngleSusceptanceLaw'
                            - 'CG_UC_MinimumVoltageAngle'
                            - 'CL_UC_MaximumVoltageAngle'
                        }
                        Comment: "With this set it is possible to evaluate the impact of different constraints in the result";
                    }
                }
            }
            Section UC_Constraints {
                DeclarationSection UC_OnOffLogicalConstraints {
                    Constraint CE_UC_LogicalConstraint {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Definition: VC_OnOffStatus(iTime, iNonRenewableGenerator) = VC_StartupStatus(iTime, iNonRenewableGenerator) - VC_ShutdownStatus(iTime, iNonRenewableGenerator) + VC_OnOffStatus(iTime - 1, iNonRenewableGenerator);
                    }
                }
                DeclarationSection UC_TransmissionConstraints {
                    Constraint CG_UC_MinimumTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Definition: VC_PowerTransmitted(iTime, iBus, iBus2) >= -PD_TransmissionLimits(iBus, iBus2);
                    }
                    Constraint CG_UC_MaximumTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Definition: VC_PowerTransmitted(iTime, iBus, iBus2) <= PD_TransmissionLimits(iBus, iBus2);
                    }
                    Constraint CL_UC_MaximumVoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Definition: VC_VoltageAngle(iTime, iBus) <= PI_MaximumVoltageAngle(iBus);
                    }
                    Constraint CG_UC_MinimumVoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Definition: VC_VoltageAngle(iTime, iBus) >= PI_MinimumVoltageAngle(iBus);
                    }
                    Constraint CE_UC_EnergyBalance {
                        IndexDomain: (iTime,iBus);
                        Definition: {
                            !Power I generated
                            sum(iNonRenewableGenerator | PE_GeneratorBus(iNonRenewableGenerator) = iBus,
                            VC_PowerGenerated(iTime, iNonRenewableGenerator))
                            +
                            sum(iRenewableGenerator | PE_GeneratorBus(iRenewableGenerator) = iBus,
                            PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                            
                            !Power I Received
                            +
                            sum((iBus2,iTransmissionLine) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) = 1 OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus) = 1,
                            VC_PowerTransmitted(iTime, iBus2, iBus)
                            
                            )
                            
                            !Power I Sent
                            -
                            sum((iBus2,iTransmissionLine) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) = 1 OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus) = 1,
                            VC_PowerTransmitted(iTime, iBus, iBus2)
                            +PI_EnableTransmissionLosses*VC_PowerLossByTransmission(iTime, iBus, iBus2)
                            
                            )
                            
                            - PD_LoadMW(iBus, iTime)
                            
                            !Slack
                            !- VC_Model0ED_OverGenerationSlack(iTime, iBus)*PI_AddSlackVariables
                            !+ VC_Model0ED_UnderGenerationSlack(iTime, iBus)*PI_AddSlackVariables
                            =
                            
                            0
                        }
                        Comment: "TODO: Add reserve in this constraint later";
                    }
                    Constraint CE_UC_VoltageAngleSusceptanceLaw {
                        IndexDomain: (iTime,iTransmissionLine);
                        Definition: {
                            sum((iBus,iBus2) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2),
                            
                            PI_MVABase*1000*PI_LineSusceptance(iTransmissionLine)*(
                            VC_VoltageAngle(iTime,iBus)
                            -
                            VC_VoltageAngle(iTime,iBus2))
                            
                            -
                            
                            VC_PowerTransmitted(iTime, iBus, iBus2)
                            
                            )
                            
                            = 0
                        }
                    }
                }
                DeclarationSection UC_GenerationLimitsConstraints {
                    Constraint CL_UC_MaximumGenerationNonRenewableSources {
                        IndexDomain: (iNonRenewableGenerator,iTime);
                        Definition: {
                            VC_PowerGenerated[iTime,iNonRenewableGenerator] +
                            sum(iReserveProduct,VC_Reserve(iTime,iNonRenewableGenerator,iReserveProduct))*PI_EnableReserveConstraints
                            
                            <= PI_MaximumGenerationMW[iNonRenewableGenerator]
                        }
                    }
                    Constraint CG_UC_MinimumGenerationNonRenewableSources {
                        IndexDomain: (iGenerator,iTime);
                        Definition: {
                            VC_PowerGenerated[iTime,iGenerator] +
                            sum(iReserveProduct,VC_Reserve(iTime,iGenerator,iReserveProduct))*PI_EnableReserveConstraints >=
                            
                            PI_MinimumGenerationMW[iGenerator]
                        }
                    }
                }
                DeclarationSection UC_RampConstraints {
                    Constraint CL_UC_RampUpRateRequirements {
                        IndexDomain: (iTime,iGenerator);
                        Definition: {
                            VC_PowerGenerated[iTime,iGenerator] - VC_PowerGenerated[iTime - 1,iGenerator] <=
                            PI_RampUpRate[PE_UnitGroup[iGenerator]]*PI_TimeGranularity
                        }
                    }
                    Constraint CL_UC_RampDownRateRequirements {
                        IndexDomain: (iTime,iGenerator);
                        Definition: {
                            VC_PowerGenerated[iTime - 1,iGenerator] - VC_PowerGenerated[iTime,iGenerator] <=
                            PI_RampDownRate[PE_UnitGroup[iGenerator]]*PI_TimeGranularity
                        }
                    }
                }
                DeclarationSection UC_TotalBalanceConstraints {
                    Constraint CE_UC_GenerationSatisfiesTotalLoadOverTime {
                        IndexDomain: iTime;
                        Definition: {
                            sum(iNonRenewableGenerator,VC_PowerGenerated[iTime,iNonRenewableGenerator])
                            + sum(iRenewableGenerator, PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                            
                            
                            
                            !+ sum(iBus,VC_Model0ED_UnderGenerationSlack(iTime, iBus))*PI_AddSlackVariables
                             = sum(iBus,PD_LoadMW[iBus,iTime])
                            
                            + sum((iBus,iBus2) | iBus <> iBus2,
                            VC_PowerLossByTransmission(iTime, iBus, iBus2)*PI_EnableTransmissionLosses
                            )
                            
                            ! + sum(iBus,VC_Model0ED_OverGenerationSlack(iTime, iBus)) *PI_AddSlackVariables
                        }
                    }
                }
                DeclarationSection UC_ReserveContraints {
                    Constraint CL_UC_ReserveRequirementCapacity {
                        IndexDomain: (iTime,iGenerator,iReserveRequirement);
                        Definition: sum(iReserveProduct | iReserveRequirement in S_ReserveProductsRequirements(iReserveProduct), VC_Reserve(iTime, iGenerator, iReserveProduct)) <= PI_ReserveCapacity(iGenerator, iReserveRequirement);
                    }
                    Constraint CU_UC_ReserveMinimumRequirement {
                        IndexDomain: (iTime,iReserveRequirement);
                        Definition: sum((iGenerator,iReserveProduct) | iReserveRequirement in S_ReserveProductsRequirements(iReserveProduct),VC_Reserve(iTime, iGenerator, iReserveProduct)) >= PI_SystemReserveRequirement(iTime, iReserveRequirement);
                        Comment: "Evaluate this for heat generators only. Make a subset of heat generators";
                    }
                }
            }
            Section UC_Variables {
                DeclarationSection OnOffVariables {
                    Variable VC_ShutdownStatus {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Range: free;
                        Comment: "1: if it is scheduled to shutdown, 0: otherwise";
                    }
                    Variable VC_StartupStatus {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Range: free;
                        Comment: "1: if it is scheduled to start, 0: otherwise";
                    }
                    Variable VC_OnOffStatus {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Range: binary;
                        Comment: "1: On, 0: off";
                    }
                }
            }
        }
        Section Economic_Dispatch_Model {
            Section ED_Configurations {
                DeclarationSection ED_ConstraintSetDeclarations {
                    Set S_EDVariables {
                        SubsetOf: AllVariables;
                        Definition: {
                            Common_Variables*AllVariables
                            +
                            
                            ED_Variables*AllVariables
                            
                            -
                            
                            if (not PI_EnableTranmissionConstraints) then
                            
                            {
                              'VC_Model0ED_PowerTransmitted',
                              'VC_Model0ED_VoltageAngle'
                            }
                            endif
                            
                            -
                            if (not PI_EnableReserveConstraints) then
                            
                            {
                            	'VC_Model0ED_Reserve'
                            }
                            
                            endif
                            
                            -
                            if (not PI_AddSlackVariables) then
                            
                            {
                            	'VC_Model0ED_UnderGenerationSlack',
                            	'VC_Model0ED_OverGenerationSlack'
                            }
                            
                            endif
                        }
                    }
                    Set S_EDConstraints {
                        SubsetOf: AllConstraints;
                        Definition: {
                            ED_Constraints*AllConstraints
                            
                            -
                            
                            if (not PI_EnableTranmissionConstraints) then
                            
                            
                              ED_TransmissionConstraints*AllConstraints
                            
                            
                            
                            endif
                            
                            -
                            if (not PI_EnableRampingConstraints) then
                            
                            
                              ED_RampConstraints*AllConstraints
                            
                            
                            endif
                            
                            -
                            if (not PI_EnableReserveConstraints) then
                            
                            
                              ED_ReserveContraints*AllConstraints
                            
                            endif
                            
                            
                            - if (PI_EnableTranmissionConstraints) then
                            
                             'CE_Model0_GenerationSatisfiesTotalLoadOverTime'
                            
                            endif
                            
                            - 'CG_Model0ED_MaximumTransmission'
                            - 'CG_Model0ED_MinimumTransmission'
                            
                            - 'CE_Model0ED_VoltageAngleSusceptanceLaw'
                            - 'CG_Model0ED_MinimumVoltageAngle'
                            - 'CL_Model0ED_MaximumVoltageAngle'
                        }
                        Comment: "With this set it is possible to evaluate the impact of different constraints in the result";
                    }
                }
                Parameter PI_AddSlackVariables {
                    Range: binary;
                }
            }
            Section ED_Variables {
                DeclarationSection ED_CostDeclaration {
                    Variable VC_ED_TotalCost {
                        Range: free;
                        Definition: {
                            sum((iNonRenewableGenerator,iTime),PD_VariableCost[iNonRenewableGenerator]*VC_PowerGenerated[iTime,iNonRenewableGenerator])*PI_TimeGranularity
                            + sum((iTime,iBus),VC_UnderGenerationSlack(iTime,iBus))*PI_AddSlackVariables
                            + sum((iTime,iBus), VC_OverGenerationSlack(iTime, iBus))*PI_AddSlackVariables
                        }
                        Comment: "Add the time granularity in the objective sum";
                    }
                }
            }
            Section ED_ObjectiveFunction {
                MathematicalProgram M_ED_MinimizeTotalCost {
                    Objective: VC_ED_TotalCost;
                    Direction: minimize;
                    Constraints: S_EDConstraints;
                    Variables: S_EDVariables;
                    Type: Automatic;
                }
            }
            Section ED_Constraints {
                DeclarationSection ED_TransmissionConstraints {
                    Constraint CG_Model0ED_MinimumTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Definition: VC_PowerTransmitted(iTime, iBus, iBus2) >= -PD_TransmissionLimits(iBus, iBus2);
                    }
                    Constraint CG_Model0ED_MaximumTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Definition: VC_PowerTransmitted(iTime, iBus, iBus2) <= PD_TransmissionLimits(iBus, iBus2);
                    }
                    Constraint CL_Model0ED_MaximumVoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Definition: VC_VoltageAngle(iTime, iBus) <= PI_MaximumVoltageAngle(iBus);
                    }
                    Constraint CG_Model0ED_MinimumVoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Definition: VC_VoltageAngle(iTime, iBus) >= PI_MinimumVoltageAngle(iBus);
                    }
                    Constraint CE_Model0ED_EnergyBalance {
                        IndexDomain: (iTime,iBus);
                        Definition: {
                            !Power I generated
                            sum(iNonRenewableGenerator | PE_GeneratorBus(iNonRenewableGenerator) = iBus,
                            VC_PowerGenerated(iTime, iNonRenewableGenerator))
                            +
                            sum(iRenewableGenerator | PE_GeneratorBus(iRenewableGenerator) = iBus,
                            PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                            
                            !Power I Received
                            +
                            sum((iBus2,iTransmissionLine) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) = 1 OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus) = 1,
                            VC_PowerTransmitted(iTime, iBus2, iBus)
                            
                            )
                            
                            !Power I Sent
                            -
                            sum((iBus2,iTransmissionLine) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) = 1 OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus) = 1,
                            VC_PowerTransmitted(iTime, iBus, iBus2)
                            +PI_EnableTransmissionLosses*VC_PowerLossByTransmission(iTime, iBus, iBus2)
                            
                            )
                            
                            - PD_LoadMW(iBus, iTime)
                            
                            !Slack
                            !- VC_Model0ED_OverGenerationSlack(iTime, iBus)*PI_AddSlackVariables
                            !+ VC_Model0ED_UnderGenerationSlack(iTime, iBus)*PI_AddSlackVariables
                            =
                            
                            0
                        }
                        Comment: "TODO: Add reserve in this constraint later";
                    }
                    Constraint CE_Model0ED_VoltageAngleSusceptanceLaw {
                        IndexDomain: (iTime,iTransmissionLine);
                        Definition: {
                            sum((iBus,iBus2) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2),
                            
                            PI_MVABase*1000*PI_LineSusceptance(iTransmissionLine)*(
                            VC_VoltageAngle(iTime,iBus)
                            -
                            VC_VoltageAngle(iTime,iBus2))
                            
                            -
                            
                            VC_PowerTransmitted(iTime, iBus, iBus2)
                            
                            )
                            
                            = 0
                        }
                    }
                }
                DeclarationSection ED_GenerationLimitsConstraints {
                    Constraint CL_Model0_MaximumGenerationNonRenewableSources {
                        IndexDomain: (iNonRenewableGenerator,iTime);
                        Definition: {
                            VC_PowerGenerated[iTime,iNonRenewableGenerator] +
                            sum(iReserveProduct,VC_Reserve(iTime,iNonRenewableGenerator,iReserveProduct))*PI_EnableReserveConstraints
                            
                            <= PI_MaximumGenerationMW[iNonRenewableGenerator]
                        }
                    }
                    Constraint CG_Model0_MinimumGenerationNonRenewableSources {
                        IndexDomain: (iGenerator,iTime);
                        Definition: {
                            VC_PowerGenerated[iTime,iGenerator] +
                            sum(iReserveProduct,VC_Reserve(iTime,iGenerator,iReserveProduct))*PI_EnableReserveConstraints >=
                            
                            PI_MinimumGenerationMW[iGenerator]
                        }
                    }
                }
                DeclarationSection ED_RampConstraints {
                    Constraint CL_Model0_RampUpRateRequirements {
                        IndexDomain: (iTime,iGenerator);
                        Definition: {
                            VC_PowerGenerated[iTime,iGenerator] - VC_PowerGenerated[iTime - 1,iGenerator] <=
                            PI_RampUpRate[PE_UnitGroup[iGenerator]]*PI_TimeGranularity
                        }
                    }
                    Constraint CL_Model0_RampDownRateRequirements {
                        IndexDomain: (iTime,iGenerator);
                        Definition: {
                            VC_PowerGenerated[iTime - 1,iGenerator] - VC_PowerGenerated[iTime,iGenerator] <=
                            PI_RampDownRate[PE_UnitGroup[iGenerator]]*PI_TimeGranularity
                        }
                    }
                }
                DeclarationSection ED_TotalBalanceConstraints {
                    Constraint CE_Model0_GenerationSatisfiesTotalLoadOverTime {
                        IndexDomain: iTime;
                        Definition: {
                            sum(iNonRenewableGenerator,VC_PowerGenerated[iTime,iNonRenewableGenerator])
                            + sum(iRenewableGenerator, PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                            
                            
                            
                            !+ sum(iBus,VC_Model0ED_UnderGenerationSlack(iTime, iBus))*PI_AddSlackVariables
                             = sum(iBus,PD_LoadMW[iBus,iTime])
                            
                            + sum((iBus,iBus2) | iBus <> iBus2,
                            VC_PowerLossByTransmission(iTime, iBus, iBus2)*PI_EnableTransmissionLosses
                            )
                            
                            ! + sum(iBus,VC_Model0ED_OverGenerationSlack(iTime, iBus)) *PI_AddSlackVariables
                        }
                    }
                }
                DeclarationSection ED_ReserveContraints {
                    Constraint CL_ReserveRequirementCapacity {
                        IndexDomain: (iTime,iGenerator,iReserveRequirement);
                        Definition: sum(iReserveProduct | iReserveRequirement in S_ReserveProductsRequirements(iReserveProduct), VC_Reserve(iTime, iGenerator, iReserveProduct)) <= PI_ReserveCapacity(iGenerator, iReserveRequirement);
                    }
                    Constraint CU_ReserveMinimumRequirement {
                        IndexDomain: (iTime,iReserveRequirement);
                        Definition: sum((iGenerator,iReserveProduct) | iReserveRequirement in S_ReserveProductsRequirements(iReserveProduct),VC_Reserve(iTime, iGenerator, iReserveProduct)) >= PI_SystemReserveRequirement(iTime, iReserveRequirement);
                        Comment: "Evaluate this for heat generators only. Make a subset of heat generators";
                    }
                }
            }
        }
    }
    Section Page_Parameters {
        DeclarationSection Location_Marginal_Prices_Page {
            ElementParameter PE_SelectedBusForLMP {
                Range: SI_Buses;
            }
        }
        DeclarationSection AverageLoadDistributionPage {
            Parameter PD_LoadDistributionPrecision {
                Definition: 120/PI_TimeGranularity;
            }
        }
        DeclarationSection TransmissionMapPage {
            StringParameter PD_GeneratorColor {
                IndexDomain: iGenerator;
                Definition: 'yellow';
            }
            Parameter PO_GenerationByBus {
                IndexDomain: (iTime,iBus);
                Definition: sum(iGenerator | PE_GeneratorBus(iGenerator) = iBus ,PO_PowerGenerated(iTime, iGenerator) );
            }
            Parameter PO_TransmissionOut {
                IndexDomain: (iTime,iBus);
                Definition: {
                    sum(iBus2 | iBus <> iBus2 ,
                    VC_PowerTransmitted(iTime, iBus, iBus2))
                }
            }
            Parameter PO_TransmissionIn {
                IndexDomain: (iTime,iBus);
                Definition: {
                    sum(iBus2 | iBus <> iBus2
                    and VC_PowerTransmitted(iTime, iBus2, iBus) > 0, VC_PowerTransmitted(iTime, iBus2, iBus))
                }
            }
            Set SD_GeneratorsUsed {
                SubsetOf: SI_Generators;
                Index: iGeneratorUsed;
                Definition: {
                    {iGenerator | (VC_PowerGenerated(PE_SelectedPeriod, iGenerator)) > 0}
                }
            }
            Parameter PO_AbsolutePowerTransmited {
                IndexDomain: (iTime,iBus,iBus2);
                Definition: Abs(VC_PowerTransmitted(iTime, iBus, iBus2));
            }
            Parameter PO_GeneratorUsed {
                IndexDomain: (iTime,iGenerator);
                Definition: (VC_PowerGenerated(iTime, iGenerator)) > 0;
            }
            Parameter PO_TransmissionBranchesDirection {
                IndexDomain: (iBus,iBus2);
                Range: binary;
                Definition: {
                    if VC_PowerTransmitted(PE_SelectedPeriod, iBus,iBus2) > 0 then
                    	1
                    endif
                }
            }
            ElementParameter PE_SelectedPeriod {
                Range: P_TimeCalendar;
            }
        }
        DeclarationSection OptimizationSettingsPage {
            ElementParameter PE_SelectedModel {
                Range: S_ModelType;
                InitialData: {
                    'Economic Dispatch' ;
                }
            }
            Set S_ModelType {
                Definition: data { 'Unit Commitment', 'Economic Dispatch' };
            }
            Parameter PI_EnableTransmissionLosses;
            Parameter PI_EnableReserveConstraints;
            Parameter PI_EnableRampingConstraints;
            Parameter PI_EnableTranmissionConstraints;
        }
    }
    Section Input_and_Output_Data {
        Section Time {
            DeclarationSection TimeDeclaration {
                ElementParameter PE_SelectedGranularity {
                    Range: S_Granularity;
                }
                Set S_Granularity {
                    Index: iGranularity;
                    InitialData: data { 'Day', 'Hour', 'Quarter Hour', 'Minute' };
                }
                Parameter PI_TimeGranularity {
                    Range: integer;
                    InitialData: 1;
                }
                UnitParameter UP_TimeUnitParameter {
                    Quantity: SI_Time_Duration;
                    Definition: hour;
                }
                Quantity SI_WattPerTimeUnit {
                    BaseUnit: W/minute;
                }
                Quantity SI_Power {
                    BaseUnit: W;
                    Comment: "Expresses the value for the amount of energy per time unit.";
                }
                UnitParameter Q_RampRateDuration;
                Set S_DayOfWeekTypes {
                    Index: iDayofWeekType;
                    Definition: data { Wkdy, Wknd };
                }
                Set S_Seasons {
                    Index: iSeason;
                    Definition: data { Winter, Summer, Spring, Fall };
                }
                Set S_Hours {
                    Index: iHour;
                    Definition: {
                        {0..23}
                    }
                }
                Set S_DaysOfWeek {
                    Index: iDayOfWeek;
                    Definition: {
                        {1..7}
                    }
                }
                Set S_Weeks {
                    Index: iWeek;
                    Definition: {
                        {1..52}
                    }
                }
                StringParameter PS_StartDate;
                StringParameter PS_EndDate;
                Calendar P_TimeCalendar {
                    Index: iTime;
                    Unit: PI_TimeGranularity * minute;
                    BeginDate: PS_StartDate;
                    EndDate: PS_EndDate;
                    TimeslotFormat: "%c%y-%m-%d %H:%M:%S";
                }
                Calendar P_YearCalendar {
                    Index: iYearCalendar;
                    Unit: hour;
                    BeginDate: "2015-01-01 00:00:00";
                    EndDate: "2015-12-31 23:59:59";
                    TimeslotFormat: "%m/%d %H:%M:%S";
                }
                Calendar P_HourCalendar {
                    Index: iHourCalendar;
                    Unit: PI_TimeGranularity * minute;
                    BeginDate: "2015-01-01 00:00:00";
                    EndDate: "2015-01-01 23:59:59";
                    TimeslotFormat: "%H:%M:%S";
                }
                Quantity SI_Time_Duration {
                    BaseUnit: minute;
                    Conversions: {
                        hour -> minute : # -> # * 60,
                        quarterhour -> minute : # -> # * 15
                    }
                }
            }
        }
        Section Costs {
            DeclarationSection Generation_Costs {
                Parameter PI_UnitGroupVariableCost {
                    IndexDomain: iUnitGroup;
                }
                Parameter PD_VariableCost {
                    IndexDomain: iGenerator;
                    Definition: PI_UnitGroupVariableCost(PE_UnitGroup(iGenerator));
                    Comment: {
                        "Variable cost per MW generated in every generator G. Include fuel costs, carbon costs, maintenance cost, and etc.
                        For now it is"
                    }
                }
            }
        }
        Section Bus {
            DeclarationSection LoadDeclaration {
                Parameter PI_PerturbationInterpolationLevel {
                    Range: [0, 100];
                }
                Parameter PI_PeakLoadMW {
                    IndexDomain: iBus;
                    Comment: "Total Load at Peak Time.";
                }
                Parameter PD_TotalPeakLoad {
                    Definition: sum(iBus,PI_PeakLoadMW(iBus));
                }
                Parameter PD_LoadMW {
                    IndexDomain: (iBus,iTime);
                    Definition: {
                        PI_WeeklyPeakLoad( ElementCast(S_Weeks,TimeslotCharacteristic(iTime,'weekyear')) ) *
                        PI_DailyPeekLoad(ElementCast(S_DaysOfWeek,TimeslotCharacteristic(iTime,'weekday')))
                        
                        *
                        (
                        if(TimeslotCharacteristic(iTime,'weekday') <6) then
                        
                        	if ( (TimeslotCharacteristic(iTime,'weekyear') >=1 and  TimeslotCharacteristic(iTime,'weekyear') <= 8) or  (TimeslotCharacteristic(iTime,'weekyear') >=44 and  TimeslotCharacteristic(iTime,'weekyear') <=52)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Winter' , 'Wkdy' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Winter','Wkdy') )
                        
                        	elseif ( (TimeslotCharacteristic(iTime,'weekyear') >= 18 and  TimeslotCharacteristic(iTime,'weekyear') <= 30)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Summer' , 'Wkdy' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Summer','Wkdy'))
                        
                        	elseif ( (TimeslotCharacteristic(iTime,'weekyear') >= 9 and  TimeslotCharacteristic(iTime,'weekyear') <= 17)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Spring' , 'Wkdy' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Spring','Wkdy'))
                        	else
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Fall' , 'Wkdy' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Fall','Wkdy'))
                        
                        	endif
                        else
                        
                        
                        	if ( (TimeslotCharacteristic(iTime,'weekyear') >=1 and  TimeslotCharacteristic(iTime,'weekyear') <= 8) or  (TimeslotCharacteristic(iTime,'weekyear') >=44 and  TimeslotCharacteristic(iTime,'weekyear') <=52)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Winter' , 'Wknd' )
                        		+ TimeslotCharacteristic(iTime,'minute')*
                        		PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Winter','Wknd'))
                        
                        	elseif ( (TimeslotCharacteristic(iTime,'weekyear') >= 18 and  TimeslotCharacteristic(iTime,'weekyear') <= 30)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Summer' , 'Wknd' ) +
                        		TimeslotCharacteristic(iTime,'minute')*
                        		PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Summer','Wknd'))
                        
                        	elseif ( (TimeslotCharacteristic(iTime,'weekyear') >= 9 and  TimeslotCharacteristic(iTime,'weekyear') <= 17)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Spring' , 'Wknd' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Spring','Wknd'))
                        	else
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Fall' , 'Wknd' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Fall','Wknd'))
                        
                        	endif
                        
                        endif
                        
                        )
                        *
                        PI_PeakLoadMW(iBus)
                        /1000000
                        
                        *(
                        if TimeslotCharacteristic(iTime,'minute') > 0 then
                        
                        uniform(1 - PI_PerturbationInterpolationLevel/100,1 + PI_PerturbationInterpolationLevel/100)
                        else
                        	1
                        endif
                        )
                    }
                }
            }
            DeclarationSection BusCoordinatesDeclaration {
                Parameter PI_BusXCoordinate {
                    IndexDomain: iBus;
                }
                Parameter PI_BusYCoordinate {
                    IndexDomain: iBus;
                }
            }
            DeclarationSection VoltageAngleDeclaration {
                Parameter PI_MinimumVoltageAngle {
                    IndexDomain: iBus;
                    Definition: -0.6;
                }
                Parameter PI_MaximumVoltageAngle {
                    IndexDomain: iBus;
                    Definition: 0.6;
                }
            }
            DeclarationSection RenewableSourcesAvailabilityDeclaration {
                Parameter PI_WindPotential {
                    IndexDomain: (iYearCalendar,iBus);
                }
                Parameter PI_SolarPotential {
                    IndexDomain: (iYearCalendar,iBus);
                }
            }
            DeclarationSection DemandDeclaration {
                Parameter PI_WeeklyPeakLoad {
                    IndexDomain: iWeek;
                }
                Parameter PI_DailyPeekLoad {
                    IndexDomain: iDayOfWeek;
                }
                Parameter PI_HourlyPeekLoad {
                    IndexDomain: (iHour,iSeason,iDayofWeekType);
                    Comment: "Has to be separated by period time.";
                }
                Parameter PD_SobHourlyPeekSlope {
                    IndexDomain: (iHour,iSeason,iDayofWeekType);
                    Definition: {
                        if iHour = '23' then
                        
                        	(PI_HourlyPeekLoad('0',iSeason,iDayofWeekType) - PI_HourlyPeekLoad(iHour,iSeason,iDayofWeekType))/60
                        
                        else
                        
                        	(PI_HourlyPeekLoad(iHour + 1,iSeason,iDayofWeekType) - PI_HourlyPeekLoad(iHour,iSeason,iDayofWeekType))/60
                        
                        endif
                    }
                    Comment: "Check what happens at 23";
                }
            }
            DeclarationSection GenerationResultsDeclaration {
                Parameter PO_AverageGeneratiorByHour {
                    IndexDomain: (iHourCalendar,iGeneratorType);
                    Definition: {
                        average(iTime |
                        ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) = ElementCast(S_Hours,TimeslotCharacteristic(iHourCalendar,'hour'))
                        and
                        ElementCast(S_Hours,TimeslotCharacteristic(iTime,'minute')) = ElementCast(S_Hours,TimeslotCharacteristic(iHourCalendar,'minute'))
                        and
                        ElementCast(S_Hours,TimeslotCharacteristic(iTime,'second')) = ElementCast(S_Hours,TimeslotCharacteristic(iHourCalendar,'second'))
                        ,
                        
                        PO_GenerationByGeneratorType(iTime,iGeneratorType))
                    }
                }
                Parameter PO_GenerationByGeneratorType {
                    IndexDomain: (iTime,iGeneratorType);
                    Definition: sum(iGenerator | PE_GeneratorType(iGenerator) = iGeneratorType, PO_PowerGenerated(iTime,iGenerator));
                }
            }
            DeclarationSection BusesDeclaration {
                Set SI_Buses {
                    Index: iBus, iBus2;
                    Parameter: eBus;
                }
                StringParameter PS_BusName {
                    IndexDomain: iBus;
                }
                Parameter PI_MinimumMVAROrVoltageLimit {
                    IndexDomain: iBus;
                }
                Parameter PI_MaximumMVAROrVoltageLimit {
                    IndexDomain: iBus;
                }
                Parameter PI_DesiredVoltsPU {
                    IndexDomain: iBus;
                }
                Parameter PI_BaseKV {
                    IndexDomain: iBus;
                }
                Parameter PI_GenerationMVAR {
                    IndexDomain: iGenerator;
                }
                Parameter PI_GenerationMW {
                    IndexDomain: iGenerator;
                }
                Parameter PI_LoadMVAR {
                    IndexDomain: iBus;
                }
                Parameter PI_FinalAngleDegrees {
                    IndexDomain: iBus;
                }
                Parameter PI_FinalVoltagePU {
                    IndexDomain: iBus;
                }
                Parameter PI_BusType {
                    IndexDomain: iBus;
                    Range: {
                        {1..3}
                    }
                    Comment: {
                        "So, the busy types are:
                        1 - Load Bus (No Generation)
                        2 - Generator or Plant Bus
                        3 - Swing Bus (?)"
                    }
                }
                Parameter PI_LossZoneNumber {
                    IndexDomain: iBus;
                    Range: integer;
                }
                Parameter PI_LoadFlowAreaNumber {
                    IndexDomain: iBus;
                    Range: integer;
                }
            }
        }
        Section Generator {
            DeclarationSection GeneratorsResultsDeclaration {
                Parameter PO_PowerGenerated {
                    IndexDomain: (iTime,iGenerator);
                    Definition: {
                        if(iGenerator in SD_RenewableGenerators) then
                        
                        	PD_RenewableGenerationCapacity(iTime, iGenerator)
                        
                        else
                        
                        	VC_PowerGenerated(iTime, iGenerator)
                        
                        endif
                    }
                }
            }
            DeclarationSection GeneratorsCoordinatesDeclaration {
                Parameter PI_GeneratorXCoordinate {
                    IndexDomain: iGenerator;
                    Definition: PI_BusXCoordinate(PE_GeneratorBus(iGenerator));
                }
                Parameter PI_GeneratorYCoordinate {
                    IndexDomain: iGenerator;
                    Definition: PI_BusYCoordinate(PE_GeneratorBus(iGenerator));
                }
            }
            DeclarationSection ReserveRequirementsDeclaration {
                Parameter PI_ReserveCapacity {
                    IndexDomain: (iGenerator,iReserveRequirement);
                    Range: nonnegative;
                }
                Parameter PI_SystemReserveRequirement {
                    IndexDomain: (iTime,iReserveRequirement);
                }
                Set S_ReserveProductsRequirements {
                    IndexDomain: iReserveProduct;
                    SubsetOf: S_ReserveRequirements;
                    Definition: {
                        data
                            { TSMR  : { TMSR, T10 , T30  } ,
                              TMNSR : { T10 , T30  } ,
                              TMOR  : { T30  } } ;
                    }
                }
                Set S_ReserveRequirements {
                    Index: iReserveRequirement;
                    Definition: data { TMSR, T10, T30 };
                }
                Set S_ReserveProducts {
                    Index: iReserveProduct;
                    Definition: data { TSMR, TMNSR, TMOR };
                }
            }
            DeclarationSection GeneratorsDeclaration {
                Parameter PI_GeneratorTypeOrder {
                    IndexDomain: iGeneratorType;
                }
                Set SD_RenewableGenerators {
                    SubsetOf: SI_Generators;
                    Index: iRenewableGenerator;
                    Definition: {
                        { iGenerator | PE_GeneratorType(iGenerator) = 'Wind' OR PE_GeneratorType(iGenerator) = 'Solar'}
                    }
                }
                Set SD_NonRenewableGenerators {
                    SubsetOf: SI_Generators;
                    Index: iNonRenewableGenerator;
                    Definition: {
                        { iGenerator | PE_GeneratorType(iGenerator) <> 'Wind' AND PE_GeneratorType(iGenerator) <> 'Solar'}
                    }
                }
                Set SI_Generators {
                    Index: iGenerator;
                }
                Set SI_UnitGroups {
                    Index: iUnitGroup;
                }
                Set SI_GeneratorTypes {
                    Index: iGeneratorType;
                    OrderBy: PI_GeneratorTypeOrder(iGeneratorType);
                }
                ElementParameter PE_GeneratorBus {
                    IndexDomain: iGenerator;
                    Range: SI_Buses;
                }
                ElementParameter PE_GeneratorType {
                    IndexDomain: iGenerator;
                    Range: SI_GeneratorTypes;
                }
                ElementParameter PE_UnitGroup {
                    IndexDomain: iGenerator;
                    Range: SI_UnitGroups;
                }
                Parameter PI_MaximumGenerationMW {
                    IndexDomain: iGenerator;
                }
                Parameter PI_MinimumGenerationMW {
                    IndexDomain: iGenerator;
                }
            }
            DeclarationSection UnitCyclingRestrictionandRampingRates {
                Parameter PI_MinDownTime {
                    IndexDomain: iUnitGroup;
                }
                Parameter PI_MinUpTime {
                    IndexDomain: iUnitGroup;
                }
                Parameter PI_StartTimeHot {
                    IndexDomain: iUnitGroup;
                }
                Parameter PI_StartTimeCold {
                    IndexDomain: iUnitGroup;
                }
                Parameter PI_WarmStartTime {
                    IndexDomain: iUnitGroup;
                }
                Parameter PI_RampDownRate {
                    IndexDomain: iUnitGroup;
                }
                Parameter PI_RampUpRate {
                    IndexDomain: iUnitGroup;
                }
            }
            DeclarationSection UnitStartUpHeatInputDeclaration {
                Parameter PI_HeatHotStart {
                    IndexDomain: iUnitGroup;
                }
                Parameter PI_HeatColdStart {
                    IndexDomain: iUnitGroup;
                }
            }
            DeclarationSection HeartRateAndIncrementalHeatRateDeclaration {
                Parameter PI_NetPlantHeatRate {
                    IndexDomain: (iUnitGroup,iOutputPercentage);
                }
                Parameter PI_IncrementalHeatRate {
                    IndexDomain: (iUnitGroup,iOutputPercentage);
                }
                Set S_OutputPercentages {
                    Index: iOutputPercentage;
                    Definition: {
                        {1..100}
                    }
                }
                ElementParameter PE_GeneratorFuelType {
                    IndexDomain: iUnitGroup;
                    Range: S_FuelType;
                }
                Set S_FuelType {
                    Index: iFuelType;
                    Definition: data { '#6 Oil', '#2 Oil', Coal, LWR };
                }
            }
            DeclarationSection RenewableGeneratorDeclaration {
                Parameter PD_TotalSolarGenerator {
                    Definition: count(iRenewableGenerator | PE_GeneratorType(iRenewableGenerator) = 'Solar');
                }
                Parameter PD_TotalWindGenerators {
                    Definition: count(iRenewableGenerator | PE_GeneratorType(iRenewableGenerator) = 'Wind');
                }
                Parameter PI_WindGenerationPercentage {
                    Range: [0, 100];
                    InitialData: 35;
                }
                Parameter PI_SolarGenerationPercentage {
                    Range: [0, 100];
                    Definition: 10;
                }
                Parameter PD_WindPotentialSubhourlyPeakSlope {
                    IndexDomain: (iYearCalendar,iBus);
                    Definition: (PI_WindPotential(iYearCalendar + 1, iBus) - PI_WindPotential(iYearCalendar, iBus))/60;
                }
                Parameter PD_SolarPotentialSubhourlyPeakSlope {
                    IndexDomain: (iYearCalendar,iBus);
                    Definition: (PI_SolarPotential(iYearCalendar + 1, iBus) - PI_SolarPotential(iYearCalendar, iBus))/60;
                }
                Parameter PD_RenewableGenerationCapacity {
                    IndexDomain: (iTime,iRenewableGenerator);
                    Definition: {
                        if PE_GeneratorType(iRenewableGenerator) = 'Wind' then
                        
                        sum(iYearCalendar | TimeslotCharacteristic(iYearCalendar,'hour') = TimeslotCharacteristic(iTime,'hour')
                        and TimeslotCharacteristic(iYearCalendar,'monthday') = TimeslotCharacteristic(iTime,'monthday')
                        and TimeslotCharacteristic(iYearCalendar,'month') = TimeslotCharacteristic(iTime,'month')
                        
                        ,
                        (PI_WindPotential(iYearCalendar,PE_GeneratorBus(iRenewableGenerator))
                        +
                        TimeslotCharacteristic(iTime,'minute')*PD_WindPotentialSubhourlyPeakSlope(iYearCalendar, PE_GeneratorBus(iRenewableGenerator))
                        )
                        
                        * PI_MaximumGenerationMW(iRenewableGenerator)
                        )
                        
                        else
                        
                        sum(iYearCalendar | TimeslotCharacteristic(iYearCalendar,'hour') = TimeslotCharacteristic(iTime,'hour')
                        and TimeslotCharacteristic(iYearCalendar,'monthday') = TimeslotCharacteristic(iTime,'monthday')
                        and TimeslotCharacteristic(iYearCalendar,'month') = TimeslotCharacteristic(iTime,'month')
                        
                        ,
                        (PI_SolarPotential(iYearCalendar,PE_GeneratorBus(iRenewableGenerator))
                        +
                        TimeslotCharacteristic(iTime,'minute')*PD_SolarPotentialSubhourlyPeakSlope(iYearCalendar, PE_GeneratorBus(iRenewableGenerator))
                        )
                        
                        * PI_MaximumGenerationMW(iRenewableGenerator)
                        )
                        
                        endif;
                    }
                }
            }
            DeclarationSection ParametersPageDeclaration {
                Parameter PO_GenerationCapability {
                    IndexDomain: iGeneratorType;
                    Definition: sum(iGenerator | PE_GeneratorType(iGenerator) = iGeneratorType, PI_MaximumGenerationMW(iGenerator));
                }
            }
        }
        Section Transmission {
            Parameter PD_TransmissionLoss {
                IndexDomain: (iBus,iBus2);
                Definition: {
                    sum(iTransmissionLine |
                     PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2)
                     OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus),
                    
                    PI_LineDistance(iTransmissionLine)/100
                    * PI_TransmissionLossFactorPer100Miles
                    
                    )
                }
            }
            Parameter PD_TransmissionLimits {
                IndexDomain: (iBus,iBus2) | iBus <> iBus2;
                Definition: sum(iTransmissionLine | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus), PI_LineMaximumCapacity(iTransmissionLine));
            }
            Parameter PI_TransmissionLossFactorPer100Miles {
                Definition: 0.01;
                Comment: "Set to 1% for each 100 Miles";
            }
            Parameter PI_LineDistance {
                IndexDomain: (iTransmissionLine);
            }
            Parameter PI_MVABase {
                InitialData: 100;
            }
            Set S_TransmissionLines {
                Index: iTransmissionLine;
            }
            Parameter PI_TransmissionLineBranches {
                IndexDomain: (iTransmissionLine,iBus,iBus2);
                Range: binary;
            }
            Parameter PI_LineSusceptance {
                IndexDomain: iTransmissionLine;
            }
            Parameter PI_LineMinimumCapacity {
                IndexDomain: iTransmissionLine;
            }
            Parameter PI_LineMaximumCapacity {
                IndexDomain: iTransmissionLine;
            }
        }
    }
    Section Procedures {
        Procedure RunOptimization {
            Body: {
                empty ALLVariables;
                
                if(PE_SelectedModel = 'Economic Dispatch') then
                	solve M_ED_MinimizeTotalCost;
                else
                	solve M_UC_MinimizeTotalCost;
                endif
            }
        }
        Procedure UpdateRenewableGenerationCapacity {
            Body: {
                for(iRenewableGenerator) do
                
                if PE_GeneratorType(iRenewableGenerator) = 'Wind' then
                	PI_MaximumGenerationMW(iRenewableGenerator) := ((PI_WindGenerationPercentage/100)*PD_TotalPeakLoad) / PD_TotalWindGenerators;
                else
                	PI_MaximumGenerationMW(iRenewableGenerator) := ((PI_SolarGenerationPercentage/100)*PD_TotalPeakLoad) / PD_TotalSolarGenerator;
                endif;
                
                endfor;
            }
        }
        Procedure UpdateTime;
        Procedure UpdateTimeCalendar {
            Body: {
                update P_TimeCalendar;
                update P_HourCalendar;
            }
        }
        Procedure UpdateGranularity {
            Body: {
                if PE_SelectedGranularity = 'Day' then
                	PI_TimeGranularity := 60*24;
                
                elseif PE_SelectedGranularity = 'Hour' then
                	PI_TimeGranularity := 60;
                
                elseif PE_SelectedGranularity = 'Quarter Hour' then
                
                	PI_TimeGranularity := 15;
                
                else
                	PI_TimeGranularity := 1;
                endif;
                
                UpdateTimeCalendar;
            }
        }
        StringParameter PS_IEEEData;
        StringParameter PS_IEEETestCaseFileName {
            InitialData: {
                "ieedata\\IEEReliabilityTestDataSetAimmsFormat_V3.txt" ;
            }
        }
        Procedure ImportIEEData {
            Body: {
                read from file PS_IEEETestCaseFileName;
                UpdateGranularity;
                
                UpdateRenewableGenerationCapacity;
            }
        }
        Procedure ExportData {
            Body: {
                write to file "D:\data.txt";
            }
        }
        Procedure BrowseFile {
            Body: {
                FileSelect(PS_IEEETestCaseFileName);
            }
        }
    }
    Section Optimal_Power_Flow_Models;
    Section Output_Information {
        DeclarationSection ResultsDeclaration {
            Parameter PO_Ramping {
                IndexDomain: (iTime,iNonRenewableGenerator);
                Definition: ABS(PO_PowerGenerated(iTime, iNonRenewableGenerator) - PO_PowerGenerated(iTime - 1, iNonRenewableGenerator));
            }
            Parameter PO_AverageRamping {
                IndexDomain: iGeneratorType;
                Definition: {
                    average((iTime,iGenerator) | PE_GeneratorType(iGenerator) = iGeneratorType and PO_PowerGenerated(iTime, iGenerator) > 0 ,
                    PO_Ramping(iTime, iGenerator))/PI_TimeGranularity
                }
            }
            Parameter PO_GenerationShadow {
                IndexDomain: iTime;
                Definition: CE_Model0_GenerationSatisfiesTotalLoadOverTime.ShadowPrice(iTime);
            }
            Parameter PO_LMP {
                IndexDomain: (iTime,iBus);
                Text: "Locational Marginal Price";
                Definition: CE_Model0ED_EnergyBalance.ShadowPrice(iTime, iBus);
            }
            Parameter PO_TotalLoad {
                IndexDomain: iTime;
                Definition: Sum(iBus,PD_LoadMW(iBus, iTime));
            }
        }
    }
    Procedure MainInitialization;
    Procedure MainExecution;
    Procedure MainTermination {
        Body: {
            return DataManagementExit();
        }
    }
}
