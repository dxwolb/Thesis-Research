## ams_version=1.0

Model Main_Thesis_Research {
    Section Models {
        Section Common_Elements {
            Section Common_Variables {
                DeclarationSection StorageDeclaration {
                    Variable VC_StorageDeviceDischarge {
                        IndexDomain: (iTime,iStorageDevice);
                        Range: nonnegative;
                    }
                    Variable VC_StorageDeviceCharge {
                        IndexDomain: (iTime,iStorageDevice);
                        Range: nonnegative;
                    }
                    Variable VC_StoredEnergy {
                        IndexDomain: (iTime,iStorageDevice);
                        Range: nonnegative;
                        Comment: "TODO: Change the capacity later";
                    }
                }
                DeclarationSection ReserveDeclaration {
                    Variable VC_Reserve {
                        IndexDomain: (iTime,iGenerator,iReserveProduct);
                        Range: nonnegative;
                    }
                }
                DeclarationSection LossDeclaration {
                    Variable VC_PowerLossByTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Property: Inline;
                        Definition: PD_TransmissionLoss(iBus, iBus2)*VC_PowerTransmitted(iTime, iBus, iBus2)/(1 - PD_TransmissionLoss(iBus, iBus2));
                    }
                }
                DeclarationSection TransmissionDeclaration {
                    Variable VC_PowerTransmitted {
                        IndexDomain: (iTime,iBus,iBus2);
                        Range: [0, PD_TransmissionLimits(iBus, iBus2)];
                    }
                    Variable VC_VoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Range: free;
                    }
                }
                DeclarationSection GenerationSlackDeclaration {
                    Variable VC_CurtailmentByBus {
                        IndexDomain: (iTime,iBus);
                        Range: free;
                    }
                    Variable VC_UnderGenerationSlack {
                        IndexDomain: (iTime,iBus);
                        Range: nonnegative;
                    }
                    Variable VC_OverGenerationSlack {
                        IndexDomain: (iTime,iBus);
                        Range: nonnegative;
                    }
                }
                DeclarationSection PowerGenerationDeclaration {
                    Variable VC_PowerGenerated {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Range: nonnegative;
                    }
                }
            }
        }
        Section Unit_Commitment_Model {
            Section UC_ObjectiveFunction {
                MathematicalProgram M_UC_MinimizeTotalCost {
                    Objective: VC_UC_TotalCost;
                    Direction: minimize;
                    Constraints: S_UC_Constraints;
                    Variables: S_UC_Variables;
                    Type: Automatic;
                }
            }
            Section UC_Configurations {
                DeclarationSection UC_ConstraintSetDeclarations {
                    Set S_UC_Variables {
                        SubsetOf: AllVariables;
                        Definition: {
                            Common_Variables*AllVariables
                            +
                            UC_Variables*AllVariables
                            
                            
                            -
                            
                            if (not PI_EnableTransmissionConstraints) then
                            
                            {
                              'VC_PowerTransmitted',
                              'VC_VoltageAngle'
                            }
                            endif
                            
                            -
                            if (not PI_EnableReserveConstraints) then
                            
                            {
                            	'VC_Reserve'
                            }
                            
                            endif
                            
                            -
                            if (not PI_EnableSlackVariables) then
                            
                            {
                            	'VC_UnderGenerationSlack',
                            	'VC_OverGenerationSlack'
                            }
                            
                            endif
                        }
                    }
                    Set S_UC_Constraints {
                        SubsetOf: AllConstraints;
                        Definition: {
                            UC_Constraints*AllConstraints
                            
                            -
                            
                            if (not PI_EnableTransmissionConstraints) then
                            
                            
                              UC_TransmissionConstraints*AllConstraints
                            
                            
                            endif
                            
                            -
                            if (not PI_EnableRampingConstraints) then
                            
                            
                              UC_RampConstraints*AllConstraints
                            
                            
                            endif
                            
                            -
                            if (not PI_EnableReserveConstraints) then
                            
                            
                              UC_ReserveContraints*AllConstraints
                            
                            endif
                            
                            
                            - if (PI_EnableTransmissionConstraints) then
                             'CE_UC_GenerationSatisfiesTotalLoadOverTime'
                            
                            endif
                            
                            - 'CG_UC_MaximumTransmission'
                            - 'CG_UC_MinimumTransmission'
                            !- 'CE_UC_LogicalConstraint'
                            - 'CE_UC_VoltageAngleSusceptanceLaw'
                            - 'CG_UC_MinimumVoltageAngle'
                            - 'CL_UC_MaximumVoltageAngle'
                            - 'CL_UC_ReserveRequirementCapacity'
                        }
                        Comment: "With this set it is possible to evaluate the impact of different constraints in the result";
                    }
                }
            }
            Section UC_Constraints {
                DeclarationSection UC_UptimeDowntimeConstraints {
                    Constraint CU_UC_MinimumUptime {
                        IndexDomain: (iNonRenewableGenerator,iTime);
                        Definition: {
                            sum(iTime2 | Ord(iTime2,P_TimeCalendar)>= Ord(iTime,P_TimeCalendar) and Ord(iTime2,P_TimeCalendar) < Ord(iTime,P_TimeCalendar) + PI_MinUpTime(PE_UnitGroup(iNonRenewableGenerator)) *(60/PI_TimeGranularity) ,
                            
                            VC_OnOffStatus(iTime2, iNonRenewableGenerator)) >=
                            VC_StartupStatus(iTime, iNonRenewableGenerator)*PI_MinUpTime(PE_UnitGroup(iNonRenewableGenerator)) *(60/PI_TimeGranularity)
                        }
                    }
                    Constraint CU_UC_MinimumDownTime {
                        IndexDomain: (iNonRenewableGenerator,iTime);
                        Definition: {
                            sum(iTime2 | Ord(iTime2,P_TimeCalendar)>= Ord(iTime,P_TimeCalendar) and Ord(iTime2,P_TimeCalendar) < Ord(iTime,P_TimeCalendar) + PI_MinDownTime(PE_UnitGroup(iNonRenewableGenerator))*(60/PI_TimeGranularity) ,
                            
                            (1 - VC_OnOffStatus(iTime2, iNonRenewableGenerator)) )>=
                            VC_ShutdownStatus(iTime, iNonRenewableGenerator)*PI_MinDownTime(PE_UnitGroup(iNonRenewableGenerator)) *(60/PI_TimeGranularity)
                        }
                    }
                }
                DeclarationSection UC_OnOffLogicalConstraints {
                    Constraint CE_UC_LogicalConstraint {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Definition: {
                            
                            VC_OnOffStatus(iTime, iNonRenewableGenerator)
                            
                            =
                            
                            VC_StartupStatus(iTime, iNonRenewableGenerator)
                            
                            - VC_ShutdownStatus(iTime, iNonRenewableGenerator)
                            
                             + VC_OnOffStatus(iTime - 1, iNonRenewableGenerator)
                        }
                    }
                    Constraint DebugConstraint1 {
                        IndexDomain: (iTime,iBus) | Ord(iTime) = 0;
                        Definition: {
                            VC_UnderGenerationSlack(iTime, iBus) = 0;
                        }
                    }
                }
                DeclarationSection UC_TransmissionConstraints {
                    Constraint CG_UC_MinimumTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Definition: VC_PowerTransmitted(iTime, iBus, iBus2) >= -PD_TransmissionLimits(iBus, iBus2);
                    }
                    Constraint CG_UC_MaximumTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Definition: VC_PowerTransmitted(iTime, iBus, iBus2) <= PD_TransmissionLimits(iBus, iBus2);
                    }
                    Constraint CL_UC_MaximumVoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Definition: VC_VoltageAngle(iTime, iBus) <= PI_MaximumVoltageAngle(iBus);
                    }
                    Constraint CG_UC_MinimumVoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Definition: VC_VoltageAngle(iTime, iBus) >= PI_MinimumVoltageAngle(iBus);
                    }
                    Constraint CE_UC_EnergyBalance {
                        IndexDomain: (iTime,iBus);
                        Definition: {
                            !Power I generated
                            sum(iNonRenewableGenerator | PE_GeneratorBus(iNonRenewableGenerator) = iBus,
                            VC_PowerGenerated(iTime, iNonRenewableGenerator))
                            +
                            sum(iRenewableGenerator | PE_GeneratorBus(iRenewableGenerator) = iBus,
                            PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                            
                            !Power I Received
                            +
                            sum((iBus2,iTransmissionLine) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) = 1 OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus) = 1,
                            VC_PowerTransmitted(iTime, iBus2, iBus)
                            
                            )
                            
                            !Power I Sent
                            -
                            sum((iBus2,iTransmissionLine) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) = 1 OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus) = 1,
                            VC_PowerTransmitted(iTime, iBus, iBus2)
                            +PI_EnableTransmissionLosses*VC_PowerLossByTransmission(iTime, iBus, iBus2)
                            
                            )
                            
                            - PD_LoadMW(iBus, iTime)
                            
                            !Slack
                            - VC_OverGenerationSlack(iTime, iBus)*PI_EnableSlackVariables
                            + VC_UnderGenerationSlack(iTime, iBus)*PI_EnableSlackVariables
                            =
                            
                            0
                        }
                        Comment: "TODO: Add reserve in this constraint later";
                    }
                    Constraint CE_UC_VoltageAngleSusceptanceLaw {
                        IndexDomain: (iTime,iTransmissionLine);
                        Definition: {
                            sum((iBus,iBus2) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2),
                            
                            PI_MVABase*1000*PI_LineSusceptance(iTransmissionLine)*(
                            VC_VoltageAngle(iTime,iBus)
                            -
                            VC_VoltageAngle(iTime,iBus2))
                            
                            -
                            
                            VC_PowerTransmitted(iTime, iBus, iBus2)
                            
                            )
                            
                            = 0
                        }
                    }
                }
                DeclarationSection UC_GenerationLimitsConstraints {
                    Constraint CL_UC_MaximumGenerationNonRenewableSources {
                        IndexDomain: (iNonRenewableGenerator,iTime);
                        Definition: {
                            VC_PowerGenerated[iTime,iNonRenewableGenerator]
                            + sum(iReserveProduct,VC_Reserve(iTime,iNonRenewableGenerator,iReserveProduct))*PI_EnableReserveConstraints
                            
                            <= PI_MaximumGenerationMW[iNonRenewableGenerator]*VC_OnOffStatus(iTime, iNonRenewableGenerator)
                        }
                    }
                    Constraint CG_UC_MinimumGenerationNonRenewableSources {
                        IndexDomain: (iNonRenewableGenerator,iTime);
                        Definition: {
                            VC_PowerGenerated[iTime,iNonRenewableGenerator] +
                            sum(iReserveProduct,VC_Reserve(iTime,iNonRenewableGenerator,iReserveProduct))*PI_EnableReserveConstraints
                            >=
                            PI_MinimumGenerationMW(iNonRenewableGenerator)*VC_OnOffStatus(iTime, iNonRenewableGenerator)
                            
                            
                            !PI_MinimumGenerationMW[iGenerator]
                        }
                    }
                }
                DeclarationSection UC_RampConstraints {
                    Constraint CL_UC_RampUpRateRequirements {
                        IndexDomain: (iTime,iNonRenewableGenerator) | Ord(iTime) > 1;
                        Definition: {
                            !  VC_PowerGenerated[iTime,iNonRenewableGenerator]
                            !- VC_PowerGenerated[iTime - 1,iNonRenewableGenerator]
                            !<=
                            !PI_RampUpRate[PE_UnitGroup[iNonRenewableGenerator]]
                            !*PI_TimeGranularity*VC_OnOffStatus(iTime, iNonRenewableGenerator)
                            
                              VC_PowerGenerated[iTime,iNonRenewableGenerator]
                            - VC_PowerGenerated[iTime - 1,iNonRenewableGenerator]
                            <=
                            (PI_RampUpRate[PE_UnitGroup[iNonRenewableGenerator]]
                            *PI_TimeGranularity) * (1 - VC_StartupStatus(iTime, iNonRenewableGenerator))
                            
                            + (max(PI_RampUpRate[PE_UnitGroup[iNonRenewableGenerator]]
                            *PI_TimeGranularity,PI_MinimumGenerationMW(iNonRenewableGenerator)))
                            
                            *VC_StartupStatus(iTime, iNonRenewableGenerator)
                        }
                    }
                    Constraint CL_UC_RampDownRateRequirements {
                        IndexDomain: (iTime,iNonRenewableGenerator) | Ord(iTime) > 1;
                        Definition: {
                            !VC_PowerGenerated[iTime - 1,iNonRenewableGenerator] - VC_PowerGenerated[iTime,iNonRenewableGenerator] <=
                            !PI_RampDownRate[PE_UnitGroup[iNonRenewableGenerator]]*PI_TimeGranularity*VC_OnOffStatus(iTime, iNonRenewableGenerator)
                            
                              VC_PowerGenerated[iTime-1,iNonRenewableGenerator]
                            - VC_PowerGenerated[iTime,iNonRenewableGenerator]
                            <=
                            (PI_RampDownRate[PE_UnitGroup[iNonRenewableGenerator]]
                            *PI_TimeGranularity) * (1 - VC_ShutdownStatus(iTime, iNonRenewableGenerator))
                            
                            + (max(PI_RampDownRate[PE_UnitGroup[iNonRenewableGenerator]]
                            *PI_TimeGranularity,PI_MinimumGenerationMW(iNonRenewableGenerator)))
                            
                            *VC_ShutdownStatus(iTime, iNonRenewableGenerator)
                        }
                    }
                }
                DeclarationSection UC_TotalBalanceConstraints {
                    Constraint CE_UC_GenerationSatisfiesTotalLoadOverTime {
                        IndexDomain: iTime;
                        Definition: {
                            sum(iNonRenewableGenerator,VC_PowerGenerated[iTime,iNonRenewableGenerator])
                            + sum(iRenewableGenerator, PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                            
                            
                            
                            + sum(iBus,VC_UnderGenerationSlack(iTime, iBus))*PI_EnableSlackVariables
                             = sum(iBus,PD_LoadMW[iBus,iTime])
                            
                            + sum((iBus,iBus2) | iBus <> iBus2,
                            VC_PowerLossByTransmission(iTime, iBus, iBus2)*PI_EnableTransmissionLosses
                            )
                            
                             + sum(iBus,VC_OverGenerationSlack(iTime, iBus)) *PI_EnableSlackVariables
                        }
                    }
                }
                DeclarationSection UC_ReserveContraints {
                    Constraint CL_UC_ReserveRequirementCapacity {
                        IndexDomain: (iTime,iGenerator,iReserveRequirement);
                        Definition: {
                            sum(iReserveProduct | iReserveRequirement in S_ReserveProductsRequirements(iReserveProduct),
                            VC_Reserve(iTime, iGenerator, iReserveProduct)) <=
                             PI_ReserveCapacity(iGenerator, iReserveRequirement)
                        }
                    }
                    Constraint CU_UC_ReserveMinimumRequirement {
                        IndexDomain: (iTime,iReserveRequirement);
                        Definition: {
                            sum((iGenerator,iReserveProduct) | iReserveRequirement in S_ReserveProductsRequirements(iReserveProduct),
                            VC_Reserve(iTime, iGenerator, iReserveProduct)) >=
                            PI_SystemReserveRequirement(iTime, iReserveRequirement)
                        }
                        Comment: "Evaluate this for heat generators only. Make a subset of heat generators";
                    }
                }
            }
            Section UC_Variables {
                DeclarationSection UC_Cost_Declaration {
                    Variable VC_UC_TotalCost {
                        Range: free;
                        Definition: {
                            sum((iNonRenewableGenerator,iTime),PD_VariableCost[iNonRenewableGenerator]*VC_PowerGenerated[iTime,iNonRenewableGenerator])*PI_TimeGranularity
                            + sum((iNonRenewableGenerator,iTime),PD_GeneratorStartupCost(iNonRenewableGenerator)*VC_StartupStatus(iTime, iNonRenewableGenerator))
                            + sum((iTime,iBus),VC_UnderGenerationSlack(iTime,iBus))*PI_EnableSlackVariables*1000000
                            + sum((iTime,iBus), VC_OverGenerationSlack(iTime, iBus))*PI_EnableSlackVariables*1
                        }
                        Comment: "TEmporary change it to test.";
                    }
                }
                DeclarationSection OnOffVariables {
                    Variable VC_ShutdownStatus {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Range: binary;
                        Comment: "1: if it is scheduled to shutdown, 0: otherwise";
                    }
                    Variable VC_StartupStatus {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Range: binary;
                        Comment: "1: if it is scheduled to start, 0: otherwise";
                    }
                    Variable VC_OnOffStatus {
                        IndexDomain: (iTime,iNonRenewableGenerator);
                        Range: binary;
                        Comment: "1: On, 0: off";
                    }
                }
            }
        }
        Section Economic_Dispatch_Model {
            Section ED_Configurations {
                DeclarationSection ED_ConstraintSetDeclarations {
                    Set S_EDVariables {
                        SubsetOf: AllVariables;
                        Definition: {
                            Common_Variables*AllVariables
                            +
                            
                            ED_Variables*AllVariables
                            
                            -
                            
                            if (not PI_EnableTransmissionConstraints) then
                            
                            {
                              'VC_Model0ED_PowerTransmitted',
                              'VC_Model0ED_VoltageAngle'
                            }
                            endif
                            
                            -
                            if (not PI_EnableReserveConstraints) then
                            
                            {
                            	'VC_Model0ED_Reserve'
                            }
                            
                            endif
                            
                            -
                            if (not PI_EnableSlackVariables) then
                            
                            {
                            	'VC_Model0ED_UnderGenerationSlack',
                            	'VC_Model0ED_OverGenerationSlack'
                            }
                            
                            endif
                            
                            -
                            if (not PI_EnableStorageConstraints) then
                            
                            {
                            'VC_StorageDeviceCharge',
                            'VC_StorageDeviceDischarge',
                            'VC_StoredEnergy'
                            }
                            
                            
                            endif
                        }
                    }
                    Set S_EDConstraints {
                        SubsetOf: AllConstraints;
                        Definition: {
                            ED_Constraints*AllConstraints
                            
                            -
                            
                            if (not PI_EnableTransmissionConstraints) then
                            
                            
                              ED_TransmissionConstraints*AllConstraints
                            
                            
                            
                            endif
                            
                            -
                            if (not PI_EnableRampingConstraints) then
                            
                            
                              ED_RampConstraints*AllConstraints
                            
                            
                            
                            endif
                            
                            -
                            if (not PI_EnableReserveConstraints) then
                            
                            
                              ED_ReserveContraints*AllConstraints
                            
                            endif
                            
                            -
                            if (not PI_EnableStorageConstraints) then
                            
                            
                              ED_StorageConstraints*AllConstraints
                            
                            endif
                            
                            
                            - if (PI_EnableTransmissionConstraints) then
                            
                             'CE_Model0_GenerationSatisfiesTotalLoadOverTime'
                            
                            endif
                            
                            - 'CG_Model0ED_MaximumTransmission'
                            - 'CG_Model0ED_MinimumTransmission'
                            - 'CE_Model0ED_VoltageAngleSusceptanceLaw'
                            - 'CG_Model0ED_MinimumVoltageAngle'
                            - 'CL_Model0ED_MaximumVoltageAngle'
                            - 'CL_ReserveRequirementCapacity'
                        }
                        Comment: "With this set it is possible to evaluate the impact of different constraints in the result";
                    }
                }
                Parameter PI_EnableSlackVariables {
                    Text: "Binary";
                    Range: binary;
                }
            }
            Section ED_Variables {
                DeclarationSection ED_CostDeclaration {
                    Variable VC_ED_TotalCost {
                        Range: free;
                        Definition: {
                            sum((iNonRenewableGenerator,iTime),PD_VariableCost[iNonRenewableGenerator]*VC_PowerGenerated[iTime,iNonRenewableGenerator])*PI_TimeGranularity
                            + sum((iTime,iBus),VC_UnderGenerationSlack(iTime,iBus))*PI_EnableSlackVariables*100000
                            + sum((iTime,iBus), VC_OverGenerationSlack(iTime, iBus))*PI_EnableSlackVariables*100000
                            + sum((iTime,iStorageDevice), VC_StorageDeviceDischarge(iTime, iStorageDevice))*PI_EnableStorageConstraints
                        }
                        Comment: "Add the time granularity in the objective sum";
                    }
                }
            }
            Section ED_ObjectiveFunction {
                MathematicalProgram M_ED_MinimizeTotalCost {
                    Objective: VC_ED_TotalCost;
                    Direction: minimize;
                    Constraints: S_EDConstraints;
                    Variables: S_EDVariables;
                    Type: Automatic;
                }
            }
            Section ED_Constraints {
                DeclarationSection ED_StorageConstraints {
                    Constraint CU_LowerStorageRampRate {
                        IndexDomain: (iTime,iStorageDevice) | Ord(iTime) > 1;
                        Definition: {
                            VC_StorageDeviceCharge(iTime, iStorageDevice) +  VC_StorageDeviceCharge(iTime - 1, iStorageDevice)
                            +
                            VC_StorageDeviceDischarge(iTime, iStorageDevice) + VC_StorageDeviceDischarge(iTime - 1, iStorageDevice)
                            
                            >=
                            
                            -PI_StorageDeviceRampRate(iStorageDevice)*PI_TimeGranularity
                        }
                    }
                    Constraint CL_LowerStorageRampRate {
                        IndexDomain: (iTime,iStorageDevice) | Ord(iTime) > 1;
                        Definition: {
                            VC_StorageDeviceCharge(iTime, iStorageDevice) -  VC_StorageDeviceCharge(iTime - 1, iStorageDevice)
                            
                            +
                            
                            VC_StorageDeviceDischarge(iTime, iStorageDevice) - VC_StorageDeviceDischarge(iTime - 1, iStorageDevice)
                            
                            <=
                            
                            PI_StorageDeviceRampRate(iStorageDevice)*PI_TimeGranularity
                        }
                    }
                    Constraint CE_InitialStorage {
                        IndexDomain: (iTime,iStorageDevice) | Ord(iTime) = 1;
                        Definition: {
                            VC_StoredEnergy(iTime, iStorageDevice) =
                            PI_StorageDeviceInitial(iStorageDevice)
                            + VC_StorageDeviceCharge(iTime, iStorageDevice)*PI_StorageEfficiency(iStorageDevice)
                            - VC_StorageDeviceDischarge(iTime, iStorageDevice)
                        }
                    }
                    Constraint CE_StorageVariablesLogic {
                        IndexDomain: (iTime,iStorageDevice) | Ord(iTime,P_TimeCalendar) > 1;
                        Definition: {
                            VC_StoredEnergy(iTime, iStorageDevice) =
                            VC_StoredEnergy(iTime - 1,iStorageDevice)
                            + VC_StorageDeviceCharge(iTime, iStorageDevice)*PI_StorageEfficiency(iStorageDevice)
                            - VC_StorageDeviceDischarge(iTime, iStorageDevice)
                        }
                    }
                }
                DeclarationSection ED_TransmissionConstraints {
                    Constraint CG_Model0ED_MinimumTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Definition: VC_PowerTransmitted(iTime, iBus, iBus2) >= -PD_TransmissionLimits(iBus, iBus2);
                    }
                    Constraint CG_Model0ED_MaximumTransmission {
                        IndexDomain: (iTime,iBus,iBus2);
                        Definition: VC_PowerTransmitted(iTime, iBus, iBus2) <= PD_TransmissionLimits(iBus, iBus2);
                    }
                    Constraint CL_Model0ED_MaximumVoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Definition: VC_VoltageAngle(iTime, iBus) <= PI_MaximumVoltageAngle(iBus);
                    }
                    Constraint CG_Model0ED_MinimumVoltageAngle {
                        IndexDomain: (iTime,iBus);
                        Definition: VC_VoltageAngle(iTime, iBus) >= PI_MinimumVoltageAngle(iBus);
                    }
                    Constraint CE_Model0ED_EnergyBalance {
                        IndexDomain: (iTime,iBus);
                        Definition: {
                            !Power I generated
                            sum(iNonRenewableGenerator | PE_GeneratorBus(iNonRenewableGenerator) = iBus,
                            VC_PowerGenerated(iTime, iNonRenewableGenerator))
                            +
                            sum(iRenewableGenerator | PE_GeneratorBus(iRenewableGenerator) = iBus,
                            PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                            
                            !Power I Received
                            +
                            sum((iBus2,iTransmissionLine) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) = 1 OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus) = 1,
                            VC_PowerTransmitted(iTime, iBus2, iBus)
                            
                            )
                            
                            !Power I Sent
                            -
                            sum((iBus2,iTransmissionLine) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) = 1 OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus) = 1,
                            VC_PowerTransmitted(iTime, iBus, iBus2)
                            +PI_EnableTransmissionLosses*VC_PowerLossByTransmission(iTime, iBus, iBus2)
                            
                            )
                            
                            - PD_LoadMW(iBus, iTime)
                            
                            !Slack
                            - VC_OverGenerationSlack(iTime, iBus)*PI_EnableSlackVariables
                            + VC_UnderGenerationSlack(iTime, iBus)*PI_EnableSlackVariables
                            
                            !Charging or Discharging in a Bus
                            - sum(iStorageDevice | PE_StorageDeviceLocation(iStorageDevice) = iBus, VC_StorageDeviceCharge(iTime, iStorageDevice)) *PI_EnableStorageConstraints
                            + sum(iStorageDevice | PE_StorageDeviceLocation(iStorageDevice) = iBus, VC_StorageDeviceDischarge(iTime, iStorageDevice)) *PI_EnableStorageConstraints
                            
                            =
                            
                            0
                        }
                    }
                    Constraint CE_Model0ED_VoltageAngleSusceptanceLaw {
                        IndexDomain: (iTime,iTransmissionLine);
                        Definition: {
                            sum((iBus,iBus2) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2),
                            
                            PI_MVABase*1000*PI_LineSusceptance(iTransmissionLine)*(
                            VC_VoltageAngle(iTime,iBus)
                            -
                            VC_VoltageAngle(iTime,iBus2))
                            
                            -
                            
                            VC_PowerTransmitted(iTime, iBus, iBus2)
                            
                            )
                            
                            = 0
                        }
                    }
                }
                DeclarationSection ED_GenerationLimitsConstraints {
                    Constraint CL_Model0_MaximumGenerationNonRenewableSources {
                        IndexDomain: (iNonRenewableGenerator,iTime);
                        Definition: {
                            VC_PowerGenerated[iTime,iNonRenewableGenerator] +
                            sum(iReserveProduct,VC_Reserve(iTime,iNonRenewableGenerator,iReserveProduct))*PI_EnableReserveConstraints
                            
                            <= PI_MaximumGenerationMW[iNonRenewableGenerator]
                        }
                    }
                }
                DeclarationSection ED_RampConstraints {
                    Constraint CL_Model0_RampUpRateRequirements {
                        IndexDomain: (iTime,iGenerator);
                        Definition: {
                            VC_PowerGenerated[iTime,iGenerator] - VC_PowerGenerated[iTime - 1,iGenerator] <=
                            PI_RampUpRate[PE_UnitGroup[iGenerator]]*PI_TimeGranularity
                        }
                    }
                    Constraint CL_Model0_RampDownRateRequirements {
                        IndexDomain: (iTime,iGenerator);
                        Definition: {
                            VC_PowerGenerated[iTime - 1,iGenerator] - VC_PowerGenerated[iTime,iGenerator] <=
                            PI_RampDownRate[PE_UnitGroup[iGenerator]]*PI_TimeGranularity
                        }
                    }
                }
                DeclarationSection ED_TotalBalanceConstraints {
                    Constraint CE_Model0_GenerationSatisfiesTotalLoadOverTime {
                        IndexDomain: iTime;
                        Definition: {
                            sum(iNonRenewableGenerator,VC_PowerGenerated[iTime,iNonRenewableGenerator])
                            + sum(iRenewableGenerator, PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                            
                            + sum(iBus,VC_UnderGenerationSlack(iTime, iBus))*PI_EnableSlackVariables
                            
                            + sum(iStorageDevice,VC_StorageDeviceDischarge(iTime, iStorageDevice)) * PI_EnableStorageConstraints
                            
                             = sum(iBus,PD_LoadMW[iBus,iTime])
                            
                            + sum((iBus,iBus2) | iBus <> iBus2,
                            VC_PowerLossByTransmission(iTime, iBus, iBus2)*PI_EnableTransmissionLosses
                            )
                            
                            + sum(iBus,VC_OverGenerationSlack(iTime, iBus)) *PI_EnableSlackVariables
                            
                            + sum(iStorageDevice,VC_StorageDeviceCharge(iTime, iStorageDevice)) * PI_EnableStorageConstraints
                        }
                    }
                }
                DeclarationSection ED_ReserveContraints {
                    Constraint CL_ReserveRequirementCapacity {
                        IndexDomain: (iTime,iGenerator,iReserveRequirement);
                        Definition: {
                            sum(iReserveProduct | iReserveRequirement in S_ReserveProductsRequirements(iReserveProduct),
                            VC_Reserve(iTime, iGenerator, iReserveProduct)) <=
                            PI_ReserveCapacity(iGenerator, iReserveRequirement)
                        }
                    }
                    Constraint CU_ED_ReserveMinimumRequirement {
                        IndexDomain: (iTime,iReserveRequirement);
                        Definition: {
                            sum((iGenerator,iReserveProduct) | iReserveRequirement in S_ReserveProductsRequirements(iReserveProduct),
                            VC_Reserve(iTime, iGenerator, iReserveProduct)) >=
                            
                            PI_SystemReserveRequirement(iTime, iReserveRequirement)
                        }
                        Comment: "Evaluate this for heat generators only. Make a subset of heat generators";
                    }
                }
            }
        }
    }
    Section Page_Parameters {
        DeclarationSection WindAndSolarAvailabilityPage {
            Parameter PD_AverageSolarPotential {
                IndexDomain: iBus;
                Definition: average(iYearCalendar,PI_SolarPotential(iYearCalendar, iBus));
            }
            Parameter PD_AverageWindPotential {
                IndexDomain: iBus;
                Definition: average(iYearCalendar,PI_WindPotential(iYearCalendar, iBus));
            }
            Parameter PD_HasRenewablePotential {
                IndexDomain: iBus;
                Range: binary;
                Definition: {
                    if PE_SolarorWindSelectedForNode = 'Wind' then
                    
                    	sum(iYearCalendar,PI_WindPotential(iYearCalendar, iBus)) > 0
                    
                    else
                    
                    	sum(iYearCalendar,PI_SolarPotential(iYearCalendar, iBus)) > 0
                    
                    endif
                }
            }
            Set SD_RenewableGeneratorTypes {
                SubsetOf: SI_GeneratorTypes;
                Definition: data { Wind, Solar };
            }
            ElementParameter PE_SolarorWindSelectedForNode {
                Range: SD_RenewableGeneratorTypes;
            }
            ElementParameter PE_SelectedBusforWindAvalMap {
                Range: SI_Buses;
            }
        }
        DeclarationSection NetworkPage {
            ElementParameter PE_SelectedGeneratorTypeForMap {
                Range: SI_GeneratorTypes;
            }
        }
        DeclarationSection Location_Marginal_Prices_Page {
            ElementParameter PE_SelectedBusForLMP {
                Range: SI_Buses;
            }
        }
        DeclarationSection AverageLoadDistributionPage {
            Parameter PD_LoadDistributionPrecision {
                Text: "%";
                Definition: 120/PI_TimeGranularity;
            }
        }
        DeclarationSection TransmissionMapPage {
            StringParameter PD_GeneratorColor {
                IndexDomain: iGenerator;
                Definition: 'yellow';
            }
            Parameter PO_GenerationByBus {
                IndexDomain: (iTime,iBus);
                Text: "MW";
                Definition: sum(iGenerator | PE_GeneratorBus(iGenerator) = iBus ,PO_PowerGenerated(iTime, iGenerator) );
            }
            Parameter PO_TransmissionOut {
                IndexDomain: (iTime,iBus);
                Text: "MW";
                Definition: {
                    sum(iBus2 | iBus <> iBus2 ,
                    VC_PowerTransmitted(iTime, iBus, iBus2))
                }
            }
            Parameter PO_TransmissionIn {
                IndexDomain: (iTime,iBus);
                Text: "MW";
                Definition: {
                    sum(iBus2 | iBus <> iBus2
                    and VC_PowerTransmitted(iTime, iBus2, iBus) > 0, VC_PowerTransmitted(iTime, iBus2, iBus))
                }
            }
            Set SD_GeneratorsUsed {
                SubsetOf: SI_Generators;
                Index: iGeneratorUsed;
                Definition: {
                    {iGenerator | (VC_PowerGenerated(PE_SelectedPeriod, iGenerator)) > 0}
                }
            }
            Parameter PO_AbsolutePowerTransmited {
                IndexDomain: (iTime,iBus,iBus2);
                Text: "MW";
                Definition: Abs(VC_PowerTransmitted(iTime, iBus, iBus2));
            }
            Parameter PO_GeneratorUsed {
                IndexDomain: (iTime,iGenerator);
                Text: "MW";
                Definition: (VC_PowerGenerated(iTime, iGenerator)) > 0;
            }
            Parameter PO_TransmissionBranchesDirection {
                IndexDomain: (iBus,iBus2);
                Text: "Binary";
                Range: binary;
                Definition: {
                    if VC_PowerTransmitted(PE_SelectedPeriod, iBus,iBus2) > 0 then
                    	1
                    endif
                }
            }
            ElementParameter PE_SelectedPeriod {
                Range: P_TimeCalendar;
            }
        }
        DeclarationSection OptimizationSettingsPage {
            ElementParameter PE_SelectedModel {
                Range: S_ModelType;
                InitialData: {
                    'Economic Dispatch' ;
                }
            }
            Set S_ModelType {
                Definition: data { 'Unit Commitment', 'Economic Dispatch' };
            }
            Parameter PI_EnableTransmissionLosses {
                Text: "Binary";
            }
            Parameter PI_EnableReserveConstraints {
                Text: "Binary";
            }
            Parameter PI_EnableRampingConstraints {
                Text: "Binary";
            }
            Parameter PI_EnableTransmissionConstraints {
                Text: "Binary";
            }
        }
    }
    Section Input_and_Output_Data {
        Section Time {
            DeclarationSection TimeDeclaration {
                ElementParameter PE_SelectedGranularity {
                    Range: S_Granularity;
                }
                Set S_Granularity {
                    Index: iGranularity;
                    InitialData: data { 'Day', 'Hour', 'Quarter Hour', 'Minute' };
                }
                Parameter PI_TimeGranularity {
                    Text: "minute";
                    Range: integer;
                    InitialData: 1;
                }
                UnitParameter UP_TimeUnitParameter {
                    Quantity: SI_Time_Duration;
                    Definition: hour;
                }
                Quantity SI_WattPerTimeUnit {
                    BaseUnit: W/minute;
                }
                Quantity SI_Power {
                    BaseUnit: W;
                    Comment: "Expresses the value for the amount of energy per time unit.";
                }
                UnitParameter Q_RampRateDuration;
                Set S_DayOfWeekTypes {
                    Index: iDayofWeekType;
                    Definition: data { Wkdy, Wknd };
                }
                Set S_Seasons {
                    Index: iSeason;
                    Definition: data { Winter, Summer, Spring, Fall };
                }
                Set S_Hours {
                    Index: iHour;
                    Definition: {
                        {0..23}
                    }
                }
                Set S_DaysOfWeek {
                    Index: iDayOfWeek;
                    Definition: {
                        {1..7}
                    }
                }
                Set S_Weeks {
                    Index: iWeek;
                    Definition: {
                        {1..52}
                    }
                }
                StringParameter PS_StartDate;
                StringParameter PS_EndDate;
                Calendar P_TimeCalendar {
                    Index: iTime, iTime2;
                    Unit: PI_TimeGranularity * minute;
                    BeginDate: PS_StartDate;
                    EndDate: PS_EndDate;
                    TimeslotFormat: "%c%y-%m-%d %H:%M:%S";
                }
                Calendar P_YearCalendar {
                    Index: iYearCalendar;
                    Unit: hour;
                    BeginDate: "2015-01-01 00:00:00";
                    EndDate: "2015-12-31 23:59:59";
                    TimeslotFormat: "%m/%d %H:%M:%S";
                }
                Calendar P_HourCalendar {
                    Index: iHourCalendar;
                    Unit: PI_TimeGranularity * minute;
                    BeginDate: "2015-01-01 00:00:00";
                    EndDate: "2015-01-01 23:59:59";
                    TimeslotFormat: "%H:%M:%S";
                }
                Quantity SI_Time_Duration {
                    BaseUnit: minute;
                    Conversions: {
                        hour -> minute : # -> # * 60,
                        quarterhour -> minute : # -> # * 15
                    }
                }
            }
        }
        Section Costs {
            DeclarationSection Generation_Costs {
                Parameter PI_UnitGroupVariableCost {
                    IndexDomain: iUnitGroup;
                    Text: "$";
                }
                Parameter PD_VariableCost {
                    IndexDomain: iGenerator;
                    Text: "$";
                    Definition: PI_UnitGroupVariableCost(PE_UnitGroup(iGenerator));
                    Comment: {
                        "Variable cost per MW generated in every generator G. Include fuel costs, carbon costs, maintenance cost, and etc.
                        For now it is"
                    }
                }
            }
        }
        Section Bus {
            DeclarationSection LoadDeclaration {
                Parameter PI_PerturbationInterpolationLevel {
                    Text: "%";
                    Range: [0, 100];
                    InitialData: 20;
                }
                Parameter PI_PeakLoadMW {
                    IndexDomain: iBus;
                    Text: "MW";
                    Comment: "Total Load at Peak Time.";
                }
                Parameter PD_TotalPeakLoad {
                    Text: "MW";
                    Definition: sum(iBus,PI_PeakLoadMW(iBus));
                }
                Parameter PD_LoadMW {
                    IndexDomain: (iBus,iTime);
                    Text: "MW";
                    Definition: {
                        PI_WeeklyPeakLoad( ElementCast(S_Weeks,TimeslotCharacteristic(iTime,'weekyear')) ) *
                        PI_DailyPeekLoad(ElementCast(S_DaysOfWeek,TimeslotCharacteristic(iTime,'weekday')))
                        
                        *
                        (
                        if(TimeslotCharacteristic(iTime,'weekday') <6) then
                        
                        	if ( (TimeslotCharacteristic(iTime,'weekyear') >=1 and  TimeslotCharacteristic(iTime,'weekyear') <= 8) or  (TimeslotCharacteristic(iTime,'weekyear') >=44 and  TimeslotCharacteristic(iTime,'weekyear') <=52)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Winter' , 'Wkdy' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Winter','Wkdy') )
                        
                        	elseif ( (TimeslotCharacteristic(iTime,'weekyear') >= 18 and  TimeslotCharacteristic(iTime,'weekyear') <= 30)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Summer' , 'Wkdy' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Summer','Wkdy'))
                        
                        	elseif ( (TimeslotCharacteristic(iTime,'weekyear') >= 9 and  TimeslotCharacteristic(iTime,'weekyear') <= 17)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Spring' , 'Wkdy' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Spring','Wkdy'))
                        	else
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Fall' , 'Wkdy' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Fall','Wkdy'))
                        
                        	endif
                        else
                        
                        
                        	if ( (TimeslotCharacteristic(iTime,'weekyear') >=1 and  TimeslotCharacteristic(iTime,'weekyear') <= 8) or  (TimeslotCharacteristic(iTime,'weekyear') >=44 and  TimeslotCharacteristic(iTime,'weekyear') <=52)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Winter' , 'Wknd' )
                        		+ TimeslotCharacteristic(iTime,'minute')*
                        		PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Winter','Wknd'))
                        
                        	elseif ( (TimeslotCharacteristic(iTime,'weekyear') >= 18 and  TimeslotCharacteristic(iTime,'weekyear') <= 30)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Summer' , 'Wknd' ) +
                        		TimeslotCharacteristic(iTime,'minute')*
                        		PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Summer','Wknd'))
                        
                        	elseif ( (TimeslotCharacteristic(iTime,'weekyear') >= 9 and  TimeslotCharacteristic(iTime,'weekyear') <= 17)) then
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Spring' , 'Wknd' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Spring','Wknd'))
                        	else
                        
                        		(PI_HourlyPeekLoad( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) , 'Fall' , 'Wknd' )
                        		+ TimeslotCharacteristic(iTime,'minute')
                        		*PD_SobHourlyPeekSlope( ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) ,'Fall','Wknd'))
                        
                        	endif
                        
                        endif
                        
                        )
                        *
                        PI_PeakLoadMW(iBus)
                        /1000000
                        
                        *(
                        if TimeslotCharacteristic(iTime,'minute') > 0 then
                        
                        	uniform(1 - PI_PerturbationInterpolationLevel/100,1 + PI_PerturbationInterpolationLevel/100)
                        else
                        	1
                        endif
                        )
                    }
                }
            }
            DeclarationSection BusCoordinatesDeclaration {
                Parameter PI_BusXCoordinate {
                    IndexDomain: iBus;
                    Text: "Unit";
                }
                Parameter PI_BusYCoordinate {
                    IndexDomain: iBus;
                    Text: "Unit";
                }
            }
            DeclarationSection VoltageAngleDeclaration {
                Parameter PI_MinimumVoltageAngle {
                    IndexDomain: iBus;
                    Text: "rad";
                    Definition: -0.6;
                }
                Parameter PI_MaximumVoltageAngle {
                    IndexDomain: iBus;
                    Text: "rad";
                    Definition: 0.6;
                }
            }
            DeclarationSection RenewableSourcesAvailabilityDeclaration {
                Parameter PI_WindPotential {
                    IndexDomain: (iYearCalendar,iBus);
                    Text: "MW";
                }
                Parameter PI_SolarPotential {
                    IndexDomain: (iYearCalendar,iBus);
                    Text: "MW";
                }
            }
            DeclarationSection DemandDeclaration {
                Parameter PI_WeeklyPeakLoad {
                    IndexDomain: iWeek;
                    Text: "%";
                }
                Parameter PI_DailyPeekLoad {
                    IndexDomain: iDayOfWeek;
                    Text: "MW";
                }
                Parameter PI_HourlyPeekLoad {
                    IndexDomain: (iHour,iSeason,iDayofWeekType);
                    Text: "MW";
                    Comment: "Has to be separated by period time.";
                }
                Parameter PD_SobHourlyPeekSlope {
                    IndexDomain: (iHour,iSeason,iDayofWeekType);
                    Text: "MW/minute";
                    Definition: {
                        if iHour = '23' then
                        
                        	(PI_HourlyPeekLoad('0',iSeason,iDayofWeekType) - PI_HourlyPeekLoad(iHour,iSeason,iDayofWeekType))/60
                        
                        else
                        
                        	(PI_HourlyPeekLoad(iHour + 1,iSeason,iDayofWeekType) - PI_HourlyPeekLoad(iHour,iSeason,iDayofWeekType))/60
                        
                        endif
                    }
                    Comment: "Check what happens at 23";
                }
            }
            DeclarationSection GenerationResultsDeclaration;
            DeclarationSection BusesDeclaration {
                Set SI_Buses {
                    Index: iBus, iBus2;
                    Parameter: eBus;
                }
                StringParameter PS_BusName {
                    IndexDomain: iBus;
                }
                Parameter PI_MinimumMVAROrVoltageLimit {
                    IndexDomain: iBus;
                    Text: "MVAR";
                }
                Parameter PI_MaximumMVAROrVoltageLimit {
                    IndexDomain: iBus;
                    Text: "MVAR";
                }
                Parameter PI_DesiredVoltsPU {
                    IndexDomain: iBus;
                    Text: "PU";
                }
                Parameter PI_BaseKV {
                    IndexDomain: iBus;
                    Text: "KV";
                }
                Parameter PI_GenerationMVAR {
                    IndexDomain: iGenerator;
                    Text: "MVAR";
                }
                Parameter PI_GenerationMW {
                    IndexDomain: iGenerator;
                    Text: "MW";
                }
                Parameter PI_LoadMVAR {
                    IndexDomain: iBus;
                    Text: "MVAR";
                }
                Parameter PI_FinalAngleDegrees {
                    IndexDomain: iBus;
                    Text: "rad";
                }
                Parameter PI_FinalVoltagePU {
                    IndexDomain: iBus;
                    Text: "KV";
                }
                Parameter PI_BusType {
                    IndexDomain: iBus;
                    Text: "[0-3]";
                    Range: {
                        {1..3}
                    }
                    Comment: {
                        "So, the busy types are:
                        1 - Load Bus (No Generation)
                        2 - Generator or Plant Bus
                        3 - Swing Bus (?)"
                    }
                }
                Parameter PI_LossZoneNumber {
                    IndexDomain: iBus;
                    Text: "Unit";
                    Range: integer;
                }
                Parameter PI_LoadFlowAreaNumber {
                    IndexDomain: iBus;
                    Text: "Unit";
                    Range: integer;
                }
            }
        }
        Section Generator {
            DeclarationSection GeneratorStartupShutdownCostsDeclaration {
                Parameter PD_GeneratorStartupCost {
                    IndexDomain: iNonRenewableGenerator;
                    Definition: PI_GeneratorTypeStartupCost(PE_GeneratorType(iNonRenewableGenerator));
                }
                Parameter PI_GeneratorTypeStartupCost {
                    IndexDomain: iGeneratorType;
                }
            }
            DeclarationSection GeneratorStartupParametersDeclaration {
                Parameter PI_MinimumGenerationMW {
                    IndexDomain: iNonRenewableGenerator;
                    Text: "MW";
                    Definition: PI_MinimumOperatingOutput(PE_GeneratorType(iNonRenewableGenerator))*PI_MaximumGenerationMW(iNonRenewableGenerator)/100;
                }
                Parameter PI_MinimumOperatingOutput {
                    IndexDomain: iGeneratorType;
                    Range: [0, 100];
                }
            }
            DeclarationSection GeneratorCapacityDeclaration {
                Parameter PI_UnitGroupCapacity {
                    IndexDomain: (iUnitGroup);
                }
                Parameter PI_MaximumGenerationMW {
                    IndexDomain: iGenerator;
                    Text: "MW";
                    Definition: PI_UnitGroupCapacity(PE_UnitGroup(iGenerator));
                }
            }
            DeclarationSection GeneratorsResultsDeclaration {
                Parameter PO_PowerGenerated {
                    IndexDomain: (iTime,iGenerator);
                    Text: "MM";
                    Definition: {
                        if(iGenerator in SD_RenewableGenerators) then
                        
                        	PD_RenewableGenerationCapacity(iTime, iGenerator)
                        
                        else
                        
                        	VC_PowerGenerated(iTime, iGenerator)
                        
                        endif
                    }
                }
            }
            DeclarationSection GeneratorsCoordinatesDeclaration {
                Parameter PI_GeneratorXCoordinate {
                    IndexDomain: iGenerator;
                    Text: "Unit";
                    Definition: PI_BusXCoordinate(PE_GeneratorBus(iGenerator));
                }
                Parameter PI_GeneratorYCoordinate {
                    IndexDomain: iGenerator;
                    Text: "Unit";
                    Definition: PI_BusYCoordinate(PE_GeneratorBus(iGenerator));
                }
            }
            DeclarationSection ReserveRequirementsDeclaration {
                Parameter PI_OperatingReserveFraction {
                    Definition: 0.075;
                }
                Parameter PI_ReserveCapacity {
                    IndexDomain: (iGenerator,iReserveRequirement);
                    Text: "MW";
                    Range: nonnegative;
                }
                Parameter PI_SystemReserveRequirement {
                    IndexDomain: (iTime,iReserveRequirement);
                    Text: "%";
                    Definition: PI_OperatingReserveFraction*sum(iBus,PD_LoadMW(iBus, iTime));
                }
                Set S_ReserveProductsRequirements {
                    IndexDomain: iReserveProduct;
                    SubsetOf: S_ReserveRequirements;
                    Definition: {
                        data
                            { TSMR  : { TMSR, T10 , T30  } ,
                              TMNSR : { T10 , T30  } ,
                              TMOR  : { T30  } } ;
                    }
                }
                Set S_ReserveRequirements {
                    Index: iReserveRequirement;
                    Definition: data { TMSR, T10, T30 };
                }
                Set S_ReserveProducts {
                    Index: iReserveProduct;
                    Definition: data { TSMR, TMNSR, TMOR };
                }
            }
            DeclarationSection GeneratorsDeclaration {
                Parameter PI_GeneratorTypeOrder {
                    IndexDomain: iGeneratorType;
                    Text: "Unit";
                }
                Set SD_RenewableGenerators {
                    SubsetOf: SI_Generators;
                    Index: iRenewableGenerator;
                    Definition: {
                        { iGenerator | PE_GeneratorType(iGenerator) = 'Wind' OR PE_GeneratorType(iGenerator) = 'Solar'}
                    }
                }
                Set SD_NonRenewableGenerators {
                    SubsetOf: SI_Generators;
                    Index: iNonRenewableGenerator;
                    Definition: {
                        { iGenerator | PE_GeneratorType(iGenerator) <> 'Wind' AND PE_GeneratorType(iGenerator) <> 'Solar'}
                    }
                }
                Set SI_Generators {
                    Index: iGenerator;
                }
                Set SI_UnitGroups {
                    Index: iUnitGroup;
                }
                Set SI_GeneratorTypes {
                    Index: iGeneratorType;
                    OrderBy: PI_GeneratorTypeOrder(iGeneratorType);
                    InitialData: data { Wind, Solar, Nuclear, Coal, Oil, NGCC-Old, NGCC-New, NGCT-Old, 'Gap', 'St-Discharge' };
                }
                ElementParameter PE_GeneratorBus {
                    IndexDomain: iGenerator;
                    Range: SI_Buses;
                }
                ElementParameter PE_GeneratorType {
                    IndexDomain: iGenerator;
                    Range: SI_GeneratorTypes;
                }
                ElementParameter PE_UnitGroup {
                    IndexDomain: iGenerator;
                    Range: SI_UnitGroups;
                }
            }
            DeclarationSection UnitCyclingRestrictionandRampingRates {
                Parameter PI_MinDownTime {
                    IndexDomain: iUnitGroup;
                    Text: "hour";
                }
                Parameter PI_MinUpTime {
                    IndexDomain: iUnitGroup;
                    Text: "hour";
                }
                Parameter PI_StartTimeHot {
                    IndexDomain: iUnitGroup;
                    Text: "MTBU";
                }
                Parameter PI_StartTimeCold {
                    IndexDomain: iUnitGroup;
                    Text: "MTBU";
                }
                Parameter PI_WarmStartTime {
                    IndexDomain: iUnitGroup;
                    Text: "hour";
                }
                Parameter PI_RampDownRate {
                    IndexDomain: iUnitGroup;
                    Text: "MW/minute";
                }
                Parameter PI_RampUpRate {
                    IndexDomain: iUnitGroup;
                    Text: "MW/minute";
                }
            }
            DeclarationSection UnitStartUpHeatInputDeclaration {
                Parameter PI_HeatHotStart {
                    IndexDomain: iUnitGroup;
                    Text: "MTBU";
                }
                Parameter PI_HeatColdStart {
                    IndexDomain: iUnitGroup;
                    Text: "MTBU";
                }
            }
            DeclarationSection HeartRateAndIncrementalHeatRateDeclaration {
                Parameter PI_NetPlantHeatRate {
                    IndexDomain: (iUnitGroup,iOutputPercentage);
                    Text: "MTBU";
                }
                Parameter PI_IncrementalHeatRate {
                    IndexDomain: (iUnitGroup,iOutputPercentage);
                    Text: "MTBU";
                }
                Set S_OutputPercentages {
                    Index: iOutputPercentage;
                    Definition: {
                        {1..100}
                    }
                }
                ElementParameter PE_GeneratorFuelType {
                    IndexDomain: iUnitGroup;
                    Range: S_FuelType;
                }
                Set S_FuelType {
                    Index: iFuelType;
                    Definition: data { '#6 Oil', '#2 Oil', Coal, LWR };
                }
            }
            DeclarationSection RenewableGeneratorDeclaration {
                Parameter PD_TotalSolarGenerator {
                    Text: "Unit";
                    Definition: count(iRenewableGenerator | PE_GeneratorType(iRenewableGenerator) = 'Solar');
                }
                Parameter PD_TotalWindGenerators {
                    Text: "Unit";
                    Definition: count(iRenewableGenerator | PE_GeneratorType(iRenewableGenerator) = 'Wind');
                }
                Parameter PI_WindGenerationPercentage {
                    Text: "%";
                    Range: [0, 100];
                    InitialData: 35;
                }
                Parameter PI_SolarGenerationPercentage {
                    Text: "%";
                    Range: [0, 100];
                    Definition: 10;
                }
                Parameter PD_WindPotentialSubhourlyPeakSlope {
                    IndexDomain: (iYearCalendar,iBus);
                    Text: "MW/minute";
                    Definition: (PI_WindPotential(iYearCalendar + 1, iBus) - PI_WindPotential(iYearCalendar, iBus))/60;
                }
                Parameter PD_SolarPotentialSubhourlyPeakSlope {
                    IndexDomain: (iYearCalendar,iBus);
                    Text: "MW/minute";
                    Definition: (PI_SolarPotential(iYearCalendar + 1, iBus) - PI_SolarPotential(iYearCalendar, iBus))/60;
                }
                Parameter PD_RenewableGenerationCapacity {
                    IndexDomain: (iTime,iRenewableGenerator);
                    Text: "MW";
                    Definition: {
                        if PE_GeneratorType(iRenewableGenerator) = 'Wind' then
                        
                        sum(iYearCalendar | TimeslotCharacteristic(iYearCalendar,'hour') = TimeslotCharacteristic(iTime,'hour')
                        and TimeslotCharacteristic(iYearCalendar,'monthday') = TimeslotCharacteristic(iTime,'monthday')
                        and TimeslotCharacteristic(iYearCalendar,'month') = TimeslotCharacteristic(iTime,'month')
                        
                        ,
                        (PI_WindPotential(iYearCalendar,PE_GeneratorBus(iRenewableGenerator))
                        +
                        TimeslotCharacteristic(iTime,'minute')*PD_WindPotentialSubhourlyPeakSlope(iYearCalendar, PE_GeneratorBus(iRenewableGenerator))
                        )
                        
                        * PI_MaximumGenerationMW(iRenewableGenerator)
                        )
                        
                        else
                        
                        sum(iYearCalendar | TimeslotCharacteristic(iYearCalendar,'hour') = TimeslotCharacteristic(iTime,'hour')
                        and TimeslotCharacteristic(iYearCalendar,'monthday') = TimeslotCharacteristic(iTime,'monthday')
                        and TimeslotCharacteristic(iYearCalendar,'month') = TimeslotCharacteristic(iTime,'month')
                        
                        ,
                        (PI_SolarPotential(iYearCalendar,PE_GeneratorBus(iRenewableGenerator))
                        +
                        TimeslotCharacteristic(iTime,'minute')*PD_SolarPotentialSubhourlyPeakSlope(iYearCalendar, PE_GeneratorBus(iRenewableGenerator))
                        )
                        
                        * PI_MaximumGenerationMW(iRenewableGenerator)
                        )
                        
                        endif
                        
                        *(
                        if TimeslotCharacteristic(iTime,'minute') > 0 then
                        
                        uniform(1 - PI_PerturbationInterpolationLevel/100,1 + PI_PerturbationInterpolationLevel/100)
                        else
                        	1
                        endif
                        )
                        
                        ;
                    }
                }
            }
            DeclarationSection ParametersPageDeclaration {
                Parameter PO_GenerationCapability {
                    IndexDomain: iGeneratorType;
                    Text: "MW";
                    Definition: sum(iGenerator | PE_GeneratorType(iGenerator) = iGeneratorType, PI_MaximumGenerationMW(iGenerator));
                }
            }
        }
        Section Transmission {
            Parameter PD_TransmissionLoss {
                IndexDomain: (iBus,iBus2);
                Text: "MW";
                Definition: {
                    sum(iTransmissionLine |
                     PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2)
                     OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus),
                    
                    PI_LineDistance(iTransmissionLine)/100
                    * PI_TransmissionLossFactorPer100Miles
                    
                    )
                }
            }
            Parameter PD_TransmissionLimits {
                IndexDomain: (iBus,iBus2) | iBus <> iBus2;
                Text: "MW";
                Definition: sum(iTransmissionLine | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2) OR PI_TransmissionLineBranches(iTransmissionLine, iBus2, iBus), PI_LineMaximumCapacity(iTransmissionLine));
            }
            Parameter PI_TransmissionLossFactorPer100Miles {
                Text: "%";
                Definition: 0.05;
                Comment: "Set to 1% for each 100 Miles";
            }
            Parameter PI_LineDistance {
                IndexDomain: (iTransmissionLine);
                Text: "Miles";
            }
            Parameter PI_MVABase {
                Text: "MVA";
                InitialData: 100;
            }
            Set S_TransmissionLines {
                Index: iTransmissionLine;
            }
            Parameter PI_TransmissionLineBranches {
                IndexDomain: (iTransmissionLine,iBus,iBus2);
                Text: "Binary";
                Range: binary;
            }
            Parameter PI_LineSusceptance {
                IndexDomain: iTransmissionLine;
                Text: "PU";
            }
            Parameter PI_LineMinimumCapacity {
                IndexDomain: iTransmissionLine;
                Text: "MW";
            }
            Parameter PI_LineMaximumCapacity {
                IndexDomain: iTransmissionLine;
                Text: "MW";
            }
        }
        Section Storage {
            DeclarationSection StorageDataDeclaration {
                Parameter PI_StorageDeviceInitial {
                    IndexDomain: iStorageDevice;
                    Text: "Stored Energy at Start";
                }
                Parameter PI_StorageEfficiency {
                    IndexDomain: iStorageDevice;
                    Text: "Efficiency(%)";
                }
                Parameter PI_StorageLoss {
                    IndexDomain: iStorageDevice;
                    Text: "Loss(%)";
                }
                Set SI_StorageDevices {
                    Index: iStorageDevice;
                }
                Parameter PI_EnableStorageConstraints {
                    Text: "Enable Storage";
                    Range: binary;
                }
                Parameter PI_StorageDeviceRampRate {
                    IndexDomain: iStorageDevice;
                    Text: "Ramp Rate(MW/min)";
                }
                Parameter PI_StorageCapacity {
                    IndexDomain: iStorageDevice;
                    Text: "Capacity (MWh)";
                }
                ElementParameter PE_StorageDeviceLocation {
                    IndexDomain: iStorageDevice;
                    Text: "Device Location";
                    Range: SI_Buses;
                }
            }
        }
    }
    Section Procedures {
        Procedure ExportProcedure {
            Body: {
                write  PO_PowerGenerated,VC_PowerTransmitted to file "TestFile.txt";
                !write VC_PowerTransmitted to file "TestFile.txt";
            }
        }
        Procedure RunOptimization {
            Body: {
                empty ALLVariables;
                
                if(PE_SelectedModel = 'Economic Dispatch') then
                	solve M_ED_MinimizeTotalCost;
                	PD_SolutionTime := M_ED_MinimizeTotalCost.SolutionTime;
                	PD_SolverStatus := M_ED_MinimizeTotalCost.SolverStatus;
                else
                !
                	solve M_UC_MinimizeTotalCost where time_limit := 4*3600;
                !	solve M_UC_MinimizeTotalCost where MIP_Relative_Optimality_Tolerance := 0.01, time_limit := 3*3600 ;
                
                
                	PD_SolutionTime := M_UC_MinimizeTotalCost.SolutionTime;
                	PD_SolverStatus := M_UC_MinimizeTotalCost.SolverStatus;
                endif;
                
                !DialogMessage(
                !	message : "Optimization sucessful" ,
                !	title   : "Sucess");
                !
            }
        }
        Procedure UpdateRenewableGenerationCapacity {
            Body: {
                for(iRenewableGenerator) do
                
                if PE_GeneratorType(iRenewableGenerator) = 'Wind' then
                	!PI_MaximumGenerationMW(iRenewableGenerator) := ((PI_WindGenerationPercentage/100)*PD_TotalPeakLoad) / PD_TotalWindGenerators;
                else
                	!PI_MaximumGenerationMW(iRenewableGenerator) := ((PI_SolarGenerationPercentage/100)*PD_TotalPeakLoad) / PD_TotalSolarGenerator;
                endif;
                
                endfor;
            }
        }
        Procedure UpdateTime;
        Procedure UpdateTimeCalendar {
            Body: {
                update P_TimeCalendar;
                update P_HourCalendar;
            }
        }
        Procedure UpdateGranularity {
            Body: {
                if PE_SelectedGranularity = 'Day' then
                	PI_TimeGranularity := 60*24;
                
                elseif PE_SelectedGranularity = 'Hour' then
                	PI_TimeGranularity := 60;
                
                elseif PE_SelectedGranularity = 'Quarter Hour' then
                
                	PI_TimeGranularity := 15;
                
                else
                	PI_TimeGranularity := 5;
                endif;
                
                UpdateTimeCalendar;
            }
        }
        StringParameter PS_IEEEData;
        StringParameter PS_IEEETestCaseFileName {
            InitialData: {
                "ieedata\\IEEReliabilityTestDataSetAimmsFormat_V3.txt" ;
            }
        }
        Procedure ImportIEEData {
            Body: {
                read from file PS_IEEETestCaseFileName;
                UpdateGranularity;
                
                !UpdateRenewableGenerationCapacity;
            }
        }
        Procedure ExportData {
            Body: {
                write to file "D:\data.txt";
            }
        }
        Procedure BrowseFile {
            Body: {
                FileSelect(PS_IEEETestCaseFileName);
            }
        }
    }
    Section Optimal_Power_Flow_Models;
    Section Output_Information {
        DeclarationSection ResultsDeclaration {
            Parameter DebugParameter {
                Definition: {
                    !sum((iNonRenewableGenerator,iTime),PD_VariableCost[iNonRenewableGenerator]*VC_PowerGenerated[iTime,iNonRenewableGenerator])*PI_TimeGranularity
                    !sum((iNonRenewableGenerator,iTime),PD_GeneratorStartupCost(iNonRenewableGenerator)*VC_StartupStatus(iTime, iNonRenewableGenerator))
                     sum((iTime,iBus),VC_UnderGenerationSlack(iTime,iBus))*PI_EnableSlackVariables*1000000
                }
            }
            Parameter PO_OverGeneration {
                IndexDomain: iTime;
                Definition: sum(iBus,VC_OverGenerationSlack(iTime, iBus));
            }
            Set S_UnmetDemandSet {
                Definition: {
                    {'Unmet Demand'}
                }
            }
            Set SD_PowerOutputSet {
                SubsetOf: SI_GeneratorTypes;
                Definition: SI_GeneratorTypes;
            }
            Parameter PO_AverageGeneratiorByHour {
                IndexDomain: (iHourCalendar,iGeneratorType);
                Text: "MW";
                Definition: {
                    average(iTime |
                    ElementCast(S_Hours,TimeslotCharacteristic(iTime,'hour')) = ElementCast(S_Hours,TimeslotCharacteristic(iHourCalendar,'hour'))
                    and
                    ElementCast(S_Hours,TimeslotCharacteristic(iTime,'minute')) = ElementCast(S_Hours,TimeslotCharacteristic(iHourCalendar,'minute'))
                    and
                    ElementCast(S_Hours,TimeslotCharacteristic(iTime,'second')) = ElementCast(S_Hours,TimeslotCharacteristic(iHourCalendar,'second'))
                    ,
                    
                    PO_GenerationByGeneratorType(iTime,iGeneratorType))
                }
            }
            Parameter PO_GenerationByGeneratorType {
                IndexDomain: (iTime,iGeneratorType);
                Text: "MW";
                Definition: {
                    if iGeneratorType = 'Gap' then
                    	PO_UnmetDemand(iTime)
                    elseif iGeneratorType = 'St-Discharge' then
                    	sum(iStorageDevice, VC_StorageDeviceDischarge(iTime, iStorageDevice))
                    
                    else
                    	sum(iGenerator | PE_GeneratorType(iGenerator) = iGeneratorType, PO_PowerGenerated(iTime,iGenerator))
                    endif
                }
            }
            Parameter PO_UnmetDemand {
                IndexDomain: iTime;
                Definition: {
                    if PO_TotalLoad(iTime) > (sum(iNonRenewableGenerator, VC_PowerGenerated(iTime, iNonRenewableGenerator)) +
                    sum(iRenewableGenerator, PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                    + sum(iStorageDevice,VC_StorageDeviceDischarge(iTime, iStorageDevice))*PI_EnableStorageConstraints ) > 0 then
                    
                    PO_TotalLoad(iTime) -
                    (sum(iNonRenewableGenerator, VC_PowerGenerated(iTime, iNonRenewableGenerator)) +
                    sum(iRenewableGenerator, PD_RenewableGenerationCapacity(iTime, iRenewableGenerator))
                    +sum(iStorageDevice,VC_StorageDeviceDischarge(iTime, iStorageDevice))*PI_EnableStorageConstraints
                    
                    )
                    
                    else
                    
                    0
                    
                    endif
                    
                    
                    !sum(iBus, VC_UnderGenerationSlack(iTime, iBus))
                }
            }
            Parameter PO_HighLineUtilization {
                IndexDomain: iTransmissionLine;
                Definition: {
                    max(iTime,
                    PO_LineUtilization(iTime, iTransmissionLine))
                }
            }
            Parameter PO_LowLineUtilization {
                IndexDomain: iTransmissionLine;
                Definition: {
                    min(iTime,
                    PO_LineUtilization(iTime, iTransmissionLine))
                }
            }
            Parameter PO_LineUtilization {
                IndexDomain: (iTime,iTransmissionLine);
                Definition: {
                    sum((iBus,iBus2) | PI_TransmissionLineBranches(iTransmissionLine, iBus, iBus2),
                    VC_PowerTransmitted(iTime, iBus, iBus2))/PI_LineMaximumCapacity(iTransmissionLine)
                }
            }
            Parameter PD_SolutionTime;
            StringParameter PD_SolverStatus;
            Parameter PD_TotalGenerators {
                IndexDomain: iGeneratorType;
                Definition: count(iNonRenewableGenerator | PE_GeneratorType(iNonRenewableGenerator) = iGeneratorType);
            }
            Parameter PD_RampingPerUnitGroup {
                IndexDomain: (iTime,iUnitGroup);
                Definition: {
                    average(iNonRenewableGenerator |
                    PE_UnitGroup(iNonRenewableGenerator) = iUnitGroup, PO_Ramping(iTime, iNonRenewableGenerator))
                }
            }
            Parameter PO_Ramping {
                IndexDomain: (iTime,iNonRenewableGenerator);
                Text: "MW/minute";
                Definition: {
                    if (PI_MaximumGenerationMW(iNonRenewableGenerator) > 0) then
                    ABS(PO_PowerGenerated(iTime, iNonRenewableGenerator) - PO_PowerGenerated(iTime - 1, iNonRenewableGenerator))/
                    (PI_MaximumGenerationMW(iNonRenewableGenerator))
                    else
                    
                    0
                    
                    endif;
                }
            }
            Parameter PO_AverageRamping {
                IndexDomain: iGeneratorType;
                Text: "MW/minute";
                Definition: {
                    average((iTime,iGenerator) | PE_GeneratorType(iGenerator) = iGeneratorType,
                    PO_Ramping(iTime, iGenerator))/PI_TimeGranularity
                }
            }
            Parameter PO_GenerationShadow {
                IndexDomain: iTime;
                Text: "MW (?)";
                Definition: CE_Model0_GenerationSatisfiesTotalLoadOverTime.ShadowPrice(iTime);
            }
            Parameter PO_LMP {
                IndexDomain: (iTime,iBus);
                Text: "Locational Marginal Price";
                Definition: CE_Model0ED_EnergyBalance.ShadowPrice(iTime, iBus);
            }
            Parameter PO_TotalLoad {
                IndexDomain: iTime;
                Text: "MW";
                Definition: Sum(iBus,PD_LoadMW(iBus, iTime));
            }
            Parameter PO_StorageChargeByBus {
                IndexDomain: (iTime,iBus);
                Definition: sum(iStorageDevice | PE_StorageDeviceLocation(iStorageDevice) = iBus, VC_StorageDeviceCharge(iTime, iStorageDevice));
            }
            Set S_StorageStatusSet {
                Index: iStorageStatus;
                Definition: data { 'Generation', 'Charge', 'Discharge', 'Gap' };
            }
            Parameter PO_StorageStatus {
                IndexDomain: (iTime, iStorageStatus);
                Definition: {
                    if iStorageStatus = 'Generation' then
                    	sum(iGenerator,PO_PowerGenerated(iTime, iGenerator)) - sum(iStorageDevice,VC_StorageDeviceCharge(iTime, iStorageDevice))
                    	- sum(iBus,VC_OverGenerationSlack(iTime, iBus))
                    
                    elseif iStorageStatus = 'Charge' then
                    	 sum(iStorageDevice,VC_StorageDeviceCharge(iTime, iStorageDevice))
                    
                    elseif iStorageStatus = 'Discharge' then
                    	sum(iStorageDevice,VC_StorageDeviceDischarge(iTime, iStorageDevice))
                    
                    elseif iStorageStatus = 'Gap' then
                    	sum(iBus,VC_OverGenerationSlack(iTime, iBus))
                    
                    else
                    0
                    endif;
                }
            }
        }
    }
    Section Test_Case {
        Procedure Procedure_1 {
            Body: {
                
                
                PI_TimeGranularity := 5;
                
                !UpdateGranularity;
                UpdateTimeCalendar;
                
                RunOptimization
            }
        }
        Procedure ExportDataManual {
            Body: {
                write PO_GenerationByGeneratorType,PO_LineUtilization,PO_OverGeneration,VC_OnOffStatus,PD_SolutionTime,PD_SolverStatus to file "VC_NoTransmissionMode.txt" in dense mode ;
            }
        }
        DeclarationSection TestCaseParameters {
            StringParameter PS_ScenarioFileNames {
                IndexDomain: iScenario;
                InitialData: {
                    data
                    { Scenario1 : "ieedata\\\\IEEReliabilityTestDataSetAimmsFormat_Scenario1_Reference.txt",
                      Scenario2 : "ieedata\\\\IEEReliabilityTestDataSetAimmsFormat_Scenario2_CarbonFederalRule.txt",
                      Scenario3 : "ieedata\\\\IEEReliabilityTestDataSetAimmsFormat_Scenario3_AlmostGreenWorld.txt" }
                }
            }
            StringParameter PS_ScenarioNames {
                IndexDomain: iScenario;
                InitialData: {
                    data
                    { Scenario1 : "Scenario1",
                      Scenario2 : "Scenario2",
                      Scenario3 : "Scenario3" }
                    
                    !data
                    !{ Scenario3 : "Scenario3" }
                }
            }
            Set S_ScenarioSets {
                Index: iScenario;
                Definition: {
                    data { Scenario1, Scenario2, Scenario3 }
                    !data {Scenario3 }
                }
            }
        }
        Procedure RunScenario {
            Arguments: (V_ScenarioFile,V_Granularity,V_EnableTransmission,V_ScenarioName);
            Body: {
                PS_IEEETestCaseFileName := V_ScenarioFile;
                PI_TimeGranularity := V_Granularity;
                
                !UpdateGranularity;
                UpdateTimeCalendar;
                
                PI_EnableRampingConstraints := 1;
                PI_EnableReserveConstraints := 0;
                PI_EnableSlackVariables := 1;
                PI_EnableTransmissionConstraints := V_EnableTransmission;
                PI_EnableTransmissionLosses := V_EnableTransmission;
                
                
                read from file PS_IEEETestCaseFileName;
                RunOptimization;
                
                CaseFileSave(V_ScenarioName+".data",AllIdentifiers);
                !CaseCreate(V_ScenarioName,V_CaseName);
                !CaseSetCurrent( V_CaseName );
                !CaseSave(0);
                write PO_GenerationByGeneratorType,PO_LineUtilization,PO_OverGeneration,PO_UnmetDemand,VC_OnOffStatus,PD_SolutionTime,PD_SolverStatus,PO_StorageStatus to file V_ScenarioName in dense mode ;
                
                !spreadsheet::CloseWorkbook(PS_TestResultsWorkbookName,1);
            }
            ElementParameter V_CaseName {
                Range: AllCases;
            }
            Parameter L_Status;
            StringParameter L_SheetName;
            StringParameter V_ScenarioFile {
                Property: Input;
            }
            Parameter V_Granularity {
                Property: Input;
            }
            Parameter V_EnableTransmission {
                Property: Input;
            }
            StringParameter V_WorkbookName {
                Property: Input;
            }
            StringParameter V_ScenarioName {
                Property: Input;
            }
        }
        Procedure RunTestCase {
            Body: {
                PI_PerturbationInterpolationLevel := 20;
                
                !PE_SelectedModel := 'Economic Dispatch';
                !
                !!Run for Economic Dispatch
                !for(iScenario) do
                !
                !RunScenario(
                !	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                !	V_Granularity        :  60,
                !	V_EnableTransmission :  0,
                !	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_60_TN_ED.txt"
                !	);
                !RunScenario(
                !	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                !	V_Granularity        :  15,
                !	V_EnableTransmission :  0,
                !	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_15_TN_ED.txt"
                !	);
                !RunScenario(
                !	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                !	V_Granularity        :  5,
                !	V_EnableTransmission :  0,
                !	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_5_TN_ED.txt");
                !RunScenario(
                !	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                !	V_Granularity        :  60,
                !	V_EnableTransmission :  1,
                !	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_60_TY_ED.txt"
                !	);
                !RunScenario(
                !	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                !	V_Granularity        :  15,
                !	V_EnableTransmission :  1,
                !	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_15_TY_ED.txt"
                !	);
                !RunScenario(
                !	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                !	V_Granularity        :  5,
                !	V_EnableTransmission :  1,
                !	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_5_TY_ED.txt");
                !
                !endfor;
                
                PE_SelectedModel := 'Unit Commitment';
                
                !Run for Unit Commitment
                for(iScenario) do
                
                RunScenario(
                	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                	V_Granularity        :  60,
                	V_EnableTransmission :  0,
                	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_60_TN_UC.txt"
                	);
                RunScenario(
                	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                	V_Granularity        :  15,
                	V_EnableTransmission :  0,
                	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_15_TN_UC.txt"
                	);
                RunScenario(
                	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                	V_Granularity        :  5,
                	V_EnableTransmission :  0,
                	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_5_TN_UC.txt");
                RunScenario(
                	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                	V_Granularity        :  60,
                	V_EnableTransmission :  1,
                	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_60_TY_UC.txt"
                	);
                RunScenario(
                	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                	V_Granularity        :  15,
                	V_EnableTransmission :  1,
                	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_15_TY_UC.txt"
                	);
                RunScenario(
                	V_ScenarioFile       : PS_ScenarioFileNames(iScenario),
                	V_Granularity        :  5,
                	V_EnableTransmission :  1,
                	V_ScenarioName       :  PS_ScenarioNames(iScenario)+"_5_TY_UC.txt");
                
                endfor;
                
                DialogMessage(
                	message : "Run finished!" ,
                	title   : "Sucess");
            }
            Parameter L_Status;
        }
        Procedure RunScenario4TestCase {
            Body: {
                PI_PerturbationInterpolationLevel := 20;
                
                PE_SelectedModel := 'Economic Dispatch';
                L_Scenario4Name := "ieedata\\\\IEEReliabilityTestDataSetAimmsFormat_Scenario4_GreenWorld.txt";
                L_Scenario4ScenarioName := "Scenario4";
                PI_EnableStorageConstraints := 1;
                
                
                RunScenario(
                	V_ScenarioFile       : L_Scenario4Name,
                	V_Granularity        :  60,
                	V_EnableTransmission :  0,
                	V_ScenarioName       :  L_Scenario4ScenarioName+"_60_TN_ED.txt"
                	);
                RunScenario(
                	V_ScenarioFile       : L_Scenario4Name,
                	V_Granularity        :  15,
                	V_EnableTransmission :  0,
                	V_ScenarioName       :  L_Scenario4ScenarioName+"_15_TN_ED.txt"
                	);
                RunScenario(
                	V_ScenarioFile       : L_Scenario4Name,
                	V_Granularity        :  5,
                	V_EnableTransmission :  0,
                	V_ScenarioName       :  L_Scenario4ScenarioName+"_5_TN_ED.txt");
                RunScenario(
                	V_ScenarioFile       : L_Scenario4Name,
                	V_Granularity        :  60,
                	V_EnableTransmission :  1,
                	V_ScenarioName       :  L_Scenario4ScenarioName+"_60_TY_ED.txt"
                	);
                RunScenario(
                	V_ScenarioFile       : L_Scenario4Name,
                	V_Granularity        :  15,
                	V_EnableTransmission :  1,
                	V_ScenarioName       :  L_Scenario4ScenarioName+"_15_TY_ED.txt"
                	);
                RunScenario(
                	V_ScenarioFile       : L_Scenario4Name,
                	V_Granularity        :  5,
                	V_EnableTransmission :  1,
                	V_ScenarioName       :  L_Scenario4ScenarioName+"_5_TY_ED.txt");
                
                
                DialogMessage(
                	message : "Run finished!" ,
                	title   : "Sucess");
            }
            Parameter L_Status;
            StringParameter L_Scenario4ScenarioName;
            StringParameter L_Scenario4Name;
        }
    }
    Procedure MainInitialization;
    Procedure MainExecution;
    Procedure MainTermination {
        Body: {
            return DataManagementExit();
        }
    }
}
